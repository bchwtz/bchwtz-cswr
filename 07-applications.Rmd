# Applications - Graphics 

```{r, echo=FALSE, fig.cap=NULL, out.width="100%"}
knitr::include_graphics("exercises/applications_graphics/cswr_programming_R_appl_graphics.pdf")
```

## Plots with base R

base-R provides already a lot of functions to create plots; we want to take a look at them in this subsection. Since we cannot go into detail concerning all parameters and arguments the functions provide, just check them out by calling the corresponding help pages (e.g. `?plot`).

### `plot()`

`plot()` allows building two-dimensional plots by simply defining two vectors `x` and `y` as follows

```{r dens-norm, fig.cap="Density function of a normal distribution."}
x <- seq(from = -8, to = 8, by = 0.1)
y <- dnorm(x = x) # density function of the normal distribution with mean = 0 and 
# standard deviation = 1, by default
plot(x = x, y = y)
```

Alternatively, `plot()` can also handle a formula as data input like `y ~ x`. Consequently, 

```{r, eval=FALSE}
plot(y ~ x)
```

results in the same plot as in figure \@ref(fig:dens-norm).\newline
By defining the arguments `main`, `xlab` and `ylab` in `plot()`, a title for the plot, for the x and y axis can be added, respectively. Instead of plotting points, a line that goes through the points can be drawn by defining `type = "l"`. Furthermore, both - points and a line - are visualized by calling `type = "b"` (**b** stands for **b**oth); further options are possible.

To the plot above, figure \@ref(fig:dens-norm), further lines can be added by calling `lines()` for example:

```{r dens-norm-lines, fig.cap="Density functions for the normal distribution with means 0, -1 and 2."}
y2 <- dnorm(x = x, mean = -1)
y3 <- dnorm(x = x, mean = 2)
plot(x, y, main = "Normal distribution - density", type = "l")
lines(x, y2, col = "cyan")
lines(x, y3, col = "blue")
```

where we have also defined colors for the single lines via the argument `col`.
To visualize horizontal and/or vertical lines in the plot the x and y coordinates - where the lines start and end - are necessary. Adding these two lines 

```{r, eval=FALSE}
lines(x = c(0, 0), y = c(0, 0.4), col = "grey") # vertical line starts in (0, 0) and ends in (0, 0.4)
lines(x = c(-8, 8), y = c(0.2, 0.2), col = "darkgreen") # horizontal line starts in (-8, 0.2) and ends in (8, 0.2)
```

to figure \@ref(fig:dens-norm-lines) results in:

```{r dens-norm-lines2, fig.cap="Plot of three density functions for the normal distribution with means 0, -1 and 2, respectively, and a horizontal and a vertical line."}
y2 <- dnorm(x = x, mean = -1)
y3 <- dnorm(x = x, mean = 2)
plot(x, y, main = "Normal distribution - density", type = "l")
lines(x, y2, col = "cyan")
lines(x, y3, col = "blue")
lines(x = c(0, 0), y = c(0, 0.4), col = "grey") 
lines(x = c(-8, 8), y = c(0.2, 0.2), col = "darkgreen")
```


Analogously, (further) *points* can be added to a plot by `points()` and *text* by `text()`, e.g. adding

```{r, eval=FALSE}
points(x = x, y = dnorm(x = x, mean = 0, sd = 0.5), pch = 19, col = "darkblue")
```

to figure \@ref(fig:dens-norm-lines2) results in figure \@ref(fig:dens-norm-lines3):

```{r dens-norm-lines3, fig.cap="Plot of four density functions for the normal distribution.", echo=FALSE}
y2 <- dnorm(x = x, mean = -1)
y3 <- dnorm(x = x, mean = 2)
plot(x, y, main = "Normal distribution - density", type = "l")
lines(x, y2, col = "cyan")
lines(x, y3, col = "blue")
lines(x = c(0, 0), y = c(0, 0.4), col = "grey") 
lines(x = c(-8, 8), y = c(0.2, 0.2), col = "darkgreen")
points(x = x, y = dnorm(x = x, mean = 0, sd = 1.5), pch = 19, col = "darkblue")
points(x = x, y = dnorm(x = x, mean = 0, sd = 2), pch = 21, col = "khaki")
```


Several arguments exist to customize points (and text); e.g. `pch = 19` creates filled points. See `?points` and `?text` for much information.
A list of colors that can be assigned to the argument `col` is given by @Wei2021 (\url{http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf}). Instead of writing the names of the colors as @Wei2021 introduces, the hexadecimal code can also be used.


After plotting the density functions in figure \@ref(fig:dens-norm-lines), it is of interest to add a legend to the plot which can be done with `legend()`:

```{r dens-norm-lines-legend, fig.cap="Density functions for the normal distribution whose properties are annotated by the legend."}
plot(x, y, main="Normal distribution - density", type="l")
lines(x, y2, col="cyan")
lines(x, y3, col="blue")
legend(x = "topleft", legend=c("mean = 0, sd = 1", "mean = -1, sd = 1", "mean = 2, sd = 1"),
text.col=c("black", "cyan", "blue"))
```

where the first argument can be a pre-defined keyword (here: `"topleft"`) or coordinates where to position the legend. The content of the legend, i.e. descriptions of the plotted data (here the distribution functions), is presented by the argument `legend`. Here, information about the mean and standard deviation of each density function is shown in the legend.\newline
There are much more arguments of `legend()` to define, e.g.:

+ `text.col`: the color of the legend text,

+ `text.font`: the font of the legend text,

+ `pch`: plotting symbols,

+ ...


The legend in figure \@ref(fig:dens-norm-lines-legend) is bad concerning mathematical notations. Therefore, the R package `latex2exp` by @latex2exp allows integrating LaTeX into R by calling `TeX()` and using the known LaTeX-notation (`$...$`) like:

```{r, dens-norm-lines-legend2, fig.cap="(ref:dens-leg2)"}
plot(x, y, main="Normal distribution - density", type="l")
lines(x, y2, col="cyan")
lines(x, y3, col="blue")
legend("topleft", legend=c(latex2exp::TeX("$\\mu=0, \\sigma=1$"),
latex2exp::TeX("$\\mu=-1, \\sigma=1$"), latex2exp::TeX("$\\mu=2, \\sigma=1$")), 
text.col=c("black", "cyan", "blue"))
```

(ref:dens-leg2) Density functions for the normal distribution whose properties are annotated by the legend based on `latex2exp` [@latex2exp].

### Histograms and boxplots

Histograms and boxplots are helpful devices to get a closer look at the values of some variables. In the following we will focus on the `airquality` data set which consists of six variables in order to describe the daily air quality in New York (May to September 1973) from the R package `datasets` [@R]:

```{r}
head(airquality)
```

A Histogram for example of the variable `Temp` (Temperature in °F) [@R] can be created based on `hist()` like this (we already know the arguments `xlab`, `ylab` and `main` from `plot()`):

```{r}
h_temp <- hist(x = airquality$Temp, xlab = "Temperature [°F]", ylab = "Count",
               main = "Histogram - Temperature")
```

Usually, when a plot is assigned to a variable (here we assigned the histogram of `Temp` to `h_temp`), the plot will not be shown, but this is not the case here. The argument `plot` of `hist()` is set to `TRUE` by default (see `?hist`).\newline
The benefit of assigning the histogram to a variable (here: `h_temp`) is that we can access information about the plot, i.e. histogram:

```{r}
h_temp
```

From that we see the following:

- `breaks`: the bin boundaries,

- `counts`: the counts in (a,b],

- `density`: relative frequencies divided by binwidth,
here: density = `h_temp$counts / sum(h_temp$counts))/5`,

- `mids`: midpoints of the bins,

- `equidist`: whether distances between breaks are the same and

- the class of `h_temp` which is a "histogram" (see also `?hist`).

If it is desired to compare histograms with each other, it will be helpful to plot them on top of each other or side by side. In our example, we plot the histogram of `Temp` and of `Wind` on top of each other by defining `par(mfrow = c(2, 1))` (the first values indicates the number of rows (here: `2`) and the second value indicates the number of columns (here: `1`)):

```{r hist-temp-wind, fig.cap="(ref:histogram-t-w)"}
par(mfrow = c(2, 1)) # c(r,c): c(number of rows, number of columns)
hist(x = airquality$Temp, xlab = "Temperature [°F]", ylab = "Count", 
     main = "Histogram - Temp.") # main  = "" to leave out the title
hist(airquality$Wind, xlab = "Wind [mph]", ylab = "Count",
     main = "Histogram - Wind")
```

(ref:histogram-t-w) Histograms of the temperature and the wind speed of the `airquality` dataset [@R].

In order to create boxplots in base-R the function `boxplot()` is available which works similarily like `hist()` (and `plot()`).

```{r box-temp-wind, fig.cap="(ref:box-t-w)"}
par(mfrow = c(1,2)) # c(r,c): c(number of rows, number of columns)
b1 <- boxplot(x = airquality$Temp, main = "Boxplot - Temperature [°F]")
b2 <- boxplot(x = airquality$Wind, main = "Boxplot - Wind [mph]")
```

(ref:box-t-w) Boxplots of the temperature and the wind speed of the `airquality` dataset [@R].

When we assign the boxplots of the temperature (`Temp`) and the wind speed (`Wind`) to `b1` and `b2`, respectively, we get information about the boxplots. Exemplarily, we look at `b2`:

```{r}
b2
```

with its return values:

+ `stats`: lower whisker, $q_{0.25}$, $q_{0.5}$, $q_{0.75}$ (25 %-, 50 % (Median)- and 75 %-Quantile) and upper whisker (the whiskers extend to maximal $1.5 \cdot \text{ interquantile range }$ by default),

+ `n`: number of non NA observations,

+ `conf`: lower and upper extremes of the notch,

+ `out`: any data point outside the whiskers,

+ `group`: indicating to which group the outliers belong and 

+ `names`: naming the groups (see `group`).

Based on the information saved in `b2` and the functions `points()` and `text()` *important* values are marked in our boxplot (figure \@ref(fig:box-wind)).

```{r box-wind, fig.cap="(ref:b-wind)"}
boxplot(x = airquality$Wind, main = "Boxplot - Wind [mph]", medcol = "chocolate")
points(x = rep(1,length(b2$out)), y = b2$out, col = "orange", pch = 19)
points(x = 1, y = min(airquality$Wind), col = "khaki3", pch = 17)
points(x = 1, y = max(airquality$Wind), col = "darkred", pch = 17)
text(x = 0.7, y = b2$stats[3,], labels = b2$stats[3,], col = "chocolate")
```

(ref:b-wind) Boxplot of the wind speed of the `airquality` dataset [@R].

**Question:**

> Which values of the boxplot are marked in which color?

### Scatterplots and linear regression

When the variable `Wind` is plotted dependent on the variable `Temp` in figure \@ref(fig:scatterplot-temp-wind), a negative relation is obvious: The higher the temperature, the lower the wind speed.

```{r, scatterplot-temp-wind, fig.cap="(ref:sc-temp-wind)"}
plot(x = airquality$Temp, y = airquality$Wind, xlab = "Temperature [°F]",
     ylab = "Wind [mph]")
```

(ref:sc-temp-wind) Scatterplot of the wind speed dependent on the temperature [°F] of the `airquality` data set [@R].

Based on the relation between `Temp` and `Wind`, we define a linear model

```{r}
air_model <- lm(Wind ~ 1 + Temp, data = airquality)
```

whose regression line can be added to our scatterplot by calling the function `abline()` like this:

```{r, echo=TRUE, eval=FALSE}
abline(air_model, col = "blue")
```

```{r, scatterplot-temp-wind-linReg, fig.cap="(ref:sc-temp-wind-linReg)"}
plot(x = airquality$Temp, y = airquality$Wind, xlab = "Temperature [°F]",
     ylab = "Wind [mph]")
abline(air_model, col = "blue")
```

(ref:sc-temp-wind-linReg) Scatterplot of the wind speed dependent on the temperature [°F] of the `airquality` data set [@R] with a linear regression line.

Since `air_model` is a regression object (see argument `reg` of `abline()`), its coefficients (intercept and slope) will be extracted by calling `coef()` and then a corresponding line is drawn based on `abline()` (see figure \@ref(fig:scatterplot-temp-wind-linReg)).

The manual page of `abline()` (see `?abline`) as well as 

```{r}
args(abline)
```

reveal that 

+ the intercept and slope (arguments `a` and `b`) can be manually defined to draw a corresponding line,

+ a horizontal line can be drawn by defining `h` (the y-value(s)) and

+ a vertical line can be drawn by defining `v` (the x-value(s)).

Remember in figure \@ref(fig:dens-norm-lines2) we added a horizontal and a vertical line by using `lines()`.

**Do the following:**

> Instead of defining the vertical and horizontal lines in figure \@ref(fig:dens-norm-lines2) by `lines()` use `abline()`.

## Plots with `ggplot2` [@ggplot2]

Another form of plots are ggplots which are based on the R package `ggplot2` by @ggplot2. As we will see, ggplots are especially helpful by handling multiple variables.\newline
The name of the package indicates that the plots are based on the **G**rammar of **G**raphics. [@ggplot2] Basically, the Grammar of Graphics is a system with strict *rules* that describe how statistical graphics are generated based on raw data. [@Wilkinson2010] This means, a defined syntax - which components are necessary to build a plot - and a semantic - how the components will be interpreted to create a plot on the whole - exist. [@Wilkinson2010; @ggplot2Cheatsheet]\newline
We are not going into detail concerning the Grammar of Graphics; there is an own book about it, see @Wilkinson2005. We will focus on how `ggplot2` realizes the Grammar of Graphics and how you can create plots with `ggplot2`. 

As the `ggplot2` Cheatsheet [@ggplot2Cheatsheet] introduces only a data set, a coordinate system (grid), geoms (visual points representing data points) as well as aesthetics (i.e. variables of the data set have to be mapped to properties of the geom) are necessary to create a graph as we will see. The `ggplot2` Cheatsheet [@ggplot2Cheatsheet] as well as the manual pages of the functions of the `ggplot2` package [@ggplot2] are the basis for the creation of the following ggplots, their descriptions and further explanations.

ggplots are divided in layers which will be concatenated by a "`+`" sign: The first layer, which cannot be leaved out, includes the data; this is realized by `ggplot()` (see code below). Its first argument is the data set (here: `df`) followed by defining which variables will be plotted inside the `aes()` function. By only calling `ggplot()` as described, no data in form of points, lines etc. will be visible since geoms have not been defined, so far.\newline
To overcome this, one of the `geom_*()` functions is called which specifies how the data will be visualized, for example by points (`geom_point()`), by a line (`geom_line()`), a boxplot (`geom_boxplot()`), a histogram (`geom_histogram()`), etc.

```{r}
df <- data.frame(x = x, y = y)
head(df)
```


```{r first-ggplot, fig.cap="(ref:ggplot1-basic)"}
ggplot(data = df, mapping = aes(x = x, y = y))+ # initialize a ggplot object
  geom_point()+ # visualize data points
ggtitle("Density function of normal distribution")+ # adding a title to the plot
xlab("x")+ # labeling the x axis
ylab("density") # labeling the y axis
```

(ref:ggplot1-basic) A simple ggplot. 

Furthermore, a title for the plot as well as for the x- and y-axis have been added to the plots, figures \@ref(fig:first-ggplot) and \@ref(fig:first-ggplot-air), and  by the functions `ggtitle()`, `xlab()` and `ylab()`, respectively, and by using the "`x`"-sign.

```{r first-ggplot-air, fig.cap="(ref:ggplot1-air)"}
ggplot(data = airquality, aes(x = Temp, y = Wind))+ ## initialization of a ggplot object
geom_point()+ ## adding points to a plot
ggtitle("Scatterplot")+ ## adding a title to the plot
xlab("Temperature [°F]")+ ## labeling the x axis
ylab("Wind [mph]") ## labeling the y axis
```

(ref:ggplot1-air) Scatterplot of temperature vs. wind speed of the `airquality` data set [@R] as a `ggplot` [@ggplot2].


## Interactive plots with `plotly` [@plotly]


```{r, echo=TRUE, eval=FALSE}
air_lm_ggplot <- ggplot(data = airquality, mapping = aes(x = Temp, y = Wind))+
geom_point()+
geom_smooth(method = "lm", se = FALSE)
ggplotly(air_lm_ggplot) # converts ggplot2 to a plotly object
```

```{r ggplotly-air-lm, fig.cap = "(ref:ggplotly-air-lm)", echo=FALSE}
knitr::include_graphics("gfx/ggplotly_air_lm.png")
```

(ref:ggplotly-air-lm) Two-dimensional plot (`plotly` object) based on `air_lm_ggplot`.


```{r, eval=FALSE}
plot_ly(airquality, x = ~Temp, y = ~Wind, z = ~Solar.R) %>%
  add_markers(color = ~Month)
```

```{r, plotly-airquality, echo=FALSE, fig.cap = "(ref:plotly-3d)"}
knitr::include_graphics("gfx/plot_ly_airquality.png")
```

(ref:plotly-3d) Three-dimensional plot (`plotly` object) based on `datasets::airquality` [@R].


