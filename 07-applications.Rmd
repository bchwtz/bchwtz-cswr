# Applications - Graphics 

```{r, echo=FALSE, fig.cap=NULL, out.width="100%"}
knitr::include_graphics("exercises/applications_graphics/cswr_programming_R_appl_graphics.pdf")
```

## Plots with base R{#plotsbaseR}

base-R provides already a lot of functions to create plots; we want to take a look at them in this subsection. Since we cannot go into detail concerning all parameters and arguments the functions provide, just check them out by calling the corresponding help pages (e.g. `?plot`).

### `plot()`

`plot()` allows building two-dimensional plots by simply defining two vectors `x` and `y` as follows

```{r dens-norm, fig.cap="Density function of a normal distribution."}
x <- seq(from = -8, to = 8, by = 0.1)
y <- dnorm(x = x) # density function of the normal distribution with mean = 0 and 
# standard deviation = 1, by default
plot(x = x, y = y)
```

Alternatively, `plot()` can also handle a formula as data input like `y ~ x`. Consequently, 

```{r, eval=FALSE}
plot(y ~ x)
```

results in the same plot as in figure \@ref(fig:dens-norm).\newline
By defining the arguments `main`, `xlab` and `ylab` in `plot()`, a title for the plot, for the x and y axis can be added, respectively. Instead of plotting points, a line that goes through the points can be drawn by defining `type = "l"`. Furthermore, both - points and a line - are visualized by calling `type = "b"` (**b** stands for **b**oth); further options are possible.

To the plot above, figure \@ref(fig:dens-norm), further lines can be added by calling `lines()` for example:

```{r dens-norm-lines, fig.cap="Density functions for the normal distribution with means 0, -1 and 2."}
y2 <- dnorm(x = x, mean = -1)
y3 <- dnorm(x = x, mean = 2)
plot(x, y, main = "Normal distribution - density", type = "l")
lines(x, y2, col = "cyan")
lines(x, y3, col = "blue")
```

where we have also defined colors for the single lines via the argument `col`.
To visualize horizontal and/or vertical lines in the plot the x and y coordinates - where the lines start and end - are necessary. Adding these two lines 

```{r, eval=FALSE}
lines(x = c(0, 0), y = c(0, 0.4), col = "grey") # vertical line starts in (0, 0) and ends in (0, 0.4)
lines(x = c(-8, 8), y = c(0.2, 0.2), col = "darkgreen") # horizontal line starts in (-8, 0.2) and ends in (8, 0.2)
```

to figure \@ref(fig:dens-norm-lines) results in:

```{r dens-norm-lines2, fig.cap="Plot of three density functions for the normal distribution with means 0, -1 and 2, respectively, and a horizontal and a vertical line."}
y2 <- dnorm(x = x, mean = -1)
y3 <- dnorm(x = x, mean = 2)
plot(x, y, main = "Normal distribution - density", type = "l")
lines(x, y2, col = "cyan")
lines(x, y3, col = "blue")
lines(x = c(0, 0), y = c(0, 0.4), col = "grey") 
lines(x = c(-8, 8), y = c(0.2, 0.2), col = "darkgreen")
```


Analogously, (further) *points* can be added to a plot by `points()` and *text* by `text()`, e.g. adding

```{r, eval=FALSE}
points(x = x, y = dnorm(x = x, mean = 0, sd = 0.5), pch = 19, col = "darkblue")
```

to figure \@ref(fig:dens-norm-lines2) results in figure \@ref(fig:dens-norm-lines3):

```{r dens-norm-lines3, fig.cap="Plot of four density functions for the normal distribution.", echo=FALSE}
y2 <- dnorm(x = x, mean = -1)
y3 <- dnorm(x = x, mean = 2)
plot(x, y, main = "Normal distribution - density", type = "l")
lines(x, y2, col = "cyan")
lines(x, y3, col = "blue")
lines(x = c(0, 0), y = c(0, 0.4), col = "grey") 
lines(x = c(-8, 8), y = c(0.2, 0.2), col = "darkgreen")
points(x = x, y = dnorm(x = x, mean = 0, sd = 1.5), pch = 19, col = "darkblue")
points(x = x, y = dnorm(x = x, mean = 0, sd = 2), pch = 21, col = "khaki")
```


Several arguments exist to customize points (and text); e.g. `pch = 19` creates filled points. See `?points` and `?text` for much information.
A list of colors that can be assigned to the argument `col` is given by @Wei2021 (\url{http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf}). Instead of writing the names of the colors as @Wei2021 introduces, the hexadecimal code can also be used.


After plotting the density functions in figure \@ref(fig:dens-norm-lines), it is of interest to add a legend to the plot which can be done with `legend()`:

```{r dens-norm-lines-legend, fig.cap="Density functions for the normal distribution whose properties are annotated by the legend."}
plot(x, y, main="Normal distribution - density", type="l")
lines(x, y2, col="cyan")
lines(x, y3, col="blue")
legend(x = "topleft", legend=c("mean = 0, sd = 1", "mean = -1, sd = 1", "mean = 2, sd = 1"),
text.col=c("black", "cyan", "blue"))
```

where the first argument can be a pre-defined keyword (here: `"topleft"`) or coordinates where to position the legend. The content of the legend, i.e. descriptions of the plotted data (here the distribution functions), is presented by the argument `legend`. Here, information about the mean and standard deviation of each density function is shown in the legend.\newline
There are much more arguments of `legend()` to define, e.g.:

+ `text.col`: the color of the legend text,

+ `text.font`: the font of the legend text,

+ `pch`: plotting symbols,

+ ...


The legend in figure \@ref(fig:dens-norm-lines-legend) is bad concerning mathematical notations. Therefore, the R package `latex2exp` by @latex2exp allows integrating LaTeX into R by calling `TeX()` and using the known LaTeX-notation (`$...$`) like:

```{r, dens-norm-lines-legend2, fig.cap="(ref:dens-leg2)"}
plot(x, y, main="Normal distribution - density", type="l")
lines(x, y2, col="cyan")
lines(x, y3, col="blue")
legend("topleft", legend=c(latex2exp::TeX("$\\mu=0, \\sigma=1$"),
latex2exp::TeX("$\\mu=-1, \\sigma=1$"), latex2exp::TeX("$\\mu=2, \\sigma=1$")), 
text.col=c("black", "cyan", "blue"))
```

(ref:dens-leg2) Density functions for the normal distribution whose properties are annotated by the legend based on `latex2exp` [@latex2exp].

### Histograms and boxplots

Histograms and boxplots are helpful devices to get a closer look at the values of some variables. In the following we will focus on the `airquality` data set which consists of six variables in order to describe the daily air quality in New York (May to September 1973) from the R package `datasets` [@R]:

```{r}
head(airquality)
```

A Histogram for example of the variable `Temp` (Temperature in °F) [@R] can be created based on `hist()` like this (we already know the arguments `xlab`, `ylab` and `main` from `plot()`):

```{r}
h_temp <- hist(x = airquality$Temp, xlab = "Temperature [°F]", ylab = "Count",
               main = "Histogram - Temperature")
```

Usually, when a plot is assigned to a variable (here we assigned the histogram of `Temp` to `h_temp`), the plot will not be shown, but this is not the case here. The argument `plot` of `hist()` is set to `TRUE` by default (see `?hist`).\newline
The benefit of assigning the histogram to a variable (here: `h_temp`) is that we can access information about the plot, i.e. histogram:

```{r}
h_temp
```

From that we see the following:

- `breaks`: the bin boundaries,

- `counts`: the counts in (a,b],

- `density`: relative frequencies divided by binwidth,
here: density = `h_temp$counts / sum(h_temp$counts))/5`,

- `mids`: midpoints of the bins,

- `equidist`: whether distances between breaks are the same and

- the class of `h_temp` which is a "histogram" (see also `?hist`).

If it is desired to compare histograms with each other, it will be helpful to plot them on top of each other or side by side. In our example, we plot the histogram of `Temp` and of `Wind` on top of each other by defining `par(mfrow = c(2, 1))` (the first values indicates the number of rows (here: `2`) and the second value indicates the number of columns (here: `1`)):

```{r hist-temp-wind, fig.cap="(ref:histogram-t-w)"}
par(mfrow = c(2, 1)) # c(r,c): c(number of rows, number of columns)
hist(x = airquality$Temp, xlab = "Temperature [°F]", ylab = "Count", 
     main = "Histogram - Temp.") # main  = "" to leave out the title
hist(airquality$Wind, xlab = "Wind [mph]", ylab = "Count",
     main = "Histogram - Wind")
```

(ref:histogram-t-w) Histograms of the temperature and the wind speed of the `airquality` dataset [@R].

In order to create boxplots in base-R the function `boxplot()` is available which works similarily like `hist()` (and `plot()`).

```{r box-temp-wind, fig.cap="(ref:box-t-w)"}
par(mfrow = c(1,2)) # c(r,c): c(number of rows, number of columns)
b1 <- boxplot(x = airquality$Temp, main = "Boxplot - Temperature [°F]")
b2 <- boxplot(x = airquality$Wind, main = "Boxplot - Wind [mph]")
```

(ref:box-t-w) Boxplots of the temperature and the wind speed of the `airquality` dataset [@R].

When we assign the boxplots of the temperature (`Temp`) and the wind speed (`Wind`) to `b1` and `b2`, respectively, we get information about the boxplots. Exemplarily, we look at `b2`:

```{r}
b2
```

with its return values:

+ `stats`: lower whisker, $q_{0.25}$, $q_{0.5}$, $q_{0.75}$ (25 %-, 50 % (Median)- and 75 %-Quantile) and upper whisker (the whiskers extend to maximal $1.5 \cdot \text{ interquantile range }$ by default),

+ `n`: number of non NA observations,

+ `conf`: lower and upper extremes of the notch,

+ `out`: any data point outside the whiskers,

+ `group`: indicating to which group the outliers belong and 

+ `names`: naming the groups (see `group`).

Based on the information saved in `b2` and the functions `points()` and `text()` *important* values are marked in our boxplot (figure \@ref(fig:box-wind)).

```{r box-wind, fig.cap="(ref:b-wind)"}
boxplot(x = airquality$Wind, main = "Boxplot - Wind [mph]", medcol = "chocolate")
points(x = rep(1,length(b2$out)), y = b2$out, col = "orange", pch = 19)
points(x = 1, y = min(airquality$Wind), col = "khaki3", pch = 17)
points(x = 1, y = max(airquality$Wind), col = "darkred", pch = 17)
text(x = 0.7, y = b2$stats[3,], labels = b2$stats[3,], col = "chocolate")
```

(ref:b-wind) Boxplot of the wind speed of the `airquality` dataset [@R].

**Question:**

> Which values of the boxplot are marked in which color?

### Scatterplots and linear regression

When the variable `Wind` is plotted dependent on the variable `Temp` in figure \@ref(fig:scatterplot-temp-wind), a negative relation is obvious: The higher the temperature, the lower the wind speed.

```{r, scatterplot-temp-wind, fig.cap="(ref:sc-temp-wind)"}
plot(x = airquality$Temp, y = airquality$Wind, xlab = "Temperature [°F]",
     ylab = "Wind [mph]")
```

(ref:sc-temp-wind) Scatterplot of the wind speed dependent on the temperature [°F] of the `airquality` data set [@R].

Based on the relation between `Temp` and `Wind`, we define a linear model

```{r}
air_model <- lm(Wind ~ 1 + Temp, data = airquality)
```

whose regression line can be added to our scatterplot by calling the function `abline()` like this:

```{r, echo=TRUE, eval=FALSE}
abline(air_model, col = "blue")
```

```{r, scatterplot-temp-wind-linReg, fig.cap="(ref:sc-temp-wind-linReg)"}
plot(x = airquality$Temp, y = airquality$Wind, xlab = "Temperature [°F]",
     ylab = "Wind [mph]")
abline(air_model, col = "blue")
```

(ref:sc-temp-wind-linReg) Scatterplot of the wind speed dependent on the temperature [°F] of the `airquality` data set [@R] with a linear regression line.

Since `air_model` is a regression object (see argument `reg` of `abline()`), its coefficients (intercept and slope) will be extracted by calling `coef()` and then a corresponding line is drawn based on `abline()` (see figure \@ref(fig:scatterplot-temp-wind-linReg)).

The manual page of `abline()` (see `?abline`) as well as 

```{r}
args(abline)
```

reveal that 

+ the intercept and slope (arguments `a` and `b`) can be manually defined to draw a corresponding line,

+ a horizontal line can be drawn by defining `h` (the y-value(s)) and

+ a vertical line can be drawn by defining `v` (the x-value(s)).

Remember in figure \@ref(fig:dens-norm-lines2) we added a horizontal and a vertical line by using `lines()`.

**Do the following:**

> Instead of defining the vertical and horizontal lines in figure \@ref(fig:dens-norm-lines2) by `lines()` use `abline()`.

## Plots with `ggplot2` [@ggplot2]

Another form of plots are ggplots which are based on the R package `ggplot2` by @ggplot2. As we will see, ggplots are especially helpful by handling multiple variables.\newline
The name of the package indicates that the plots are based on the **G**rammar of **G**raphics. [@ggplot2] Basically, the Grammar of Graphics is a system with strict *rules* that describe how statistical graphics are generated based on raw data. [@Wilkinson2010] This means, a defined syntax - which components are necessary to build a plot - and a semantic - how the components will be interpreted to create a plot on the whole - exist. [@Wilkinson2010; @ggplot2Cheatsheet]\newline
We are not going into detail concerning the Grammar of Graphics; there is an own book about it, see @Wilkinson2005. We will focus on how `ggplot2` realizes the Grammar of Graphics and how you can create plots with `ggplot2`. 

As the `ggplot2` Cheatsheet [@ggplot2Cheatsheet] introduces only a data set, a coordinate system (grid), geoms (visual points representing data points) as well as aesthetics (i.e. variables of the data set have to be mapped to properties of the geom) are necessary to create a graph as we will see. The `ggplot2` Cheatsheet [@ggplot2Cheatsheet] as well as the manual pages of the functions of the `ggplot2` package [@ggplot2] are the basis for the creation of the following ggplots, their descriptions and further explanations.

ggplots are divided in layers which will be concatenated by a "`+`" sign: The first layer, which **cannot be leaved out**, includes the data; this is realized by `ggplot()` (see code below). Its first argument is the data set (here: `df`) followed by defining which variables will be plotted inside the `aes()` function. By only calling `ggplot()` as described, no data in form of points, lines etc. will be visible since geoms have not been defined, so far.\newline
To overcome this, one of the `geom_*()` functions is called which specifies how the data will be visualized, for example by points (`geom_point()`), by a line (`geom_line()`), in form of a boxplot (`geom_boxplot()`), a histogram (`geom_histogram()`), etc.

```{r}
df <- data.frame(x = x, y = y)
head(df)
```


```{r first-ggplot, fig.cap="(ref:ggplot1-basic)"}
ggplot(data = df, mapping = aes(x = x, y = y))+ # initialize a ggplot object
  geom_point()+ # visualize data points
ggtitle("Density function of normal distribution")+ # adding a title to the plot
xlab("x")+ # labeling the x axis
ylab("density") # labeling the y axis
```

(ref:ggplot1-basic) Density function for a normal distribution as a simple ggplot. 

Furthermore, a title for the plot as well as for the x- and y-axis have been added to the plots, figures \@ref(fig:first-ggplot) and \@ref(fig:first-ggplot-air), by the functions `ggtitle()`, `xlab()` and `ylab()`, respectively, and by using the "`x`"-sign.

```{r first-ggplot-air, fig.cap="(ref:ggplot1-air)"}
ggplot(data = airquality, aes(x = Temp, y = Wind))+ ## initialization of a ggplot object
geom_point()+ ## adding points to a plot
ggtitle("Scatterplot of temperature and wind speed")+ ## adding a title to the plot
xlab("Temperature [°F]")+ ## labeling the x axis
ylab("Wind [mph]") ## labeling the y axis
```

(ref:ggplot1-air) Scatterplot of wind speed vs. temperature of the `airquality` data set [@R] as a `ggplot` [@ggplot2].

In the code of the plots (figures \@ref(fig:first-ggplot) and \@ref(fig:first-ggplot-air)), the aesthetics have been defined inside `ggplot()`. It is also possible to define the aesthetics inside the `*geom()`-function. Consequently, the following options exist:

```{r, echo=TRUE, eval=FALSE}
# option 1:
ggplot(data = airquality, mapping = aes(x = Temp, y = Wind))+ # initialize a ggplot object
 geom_point()
 # option 2:
ggplot(data = airquality)+
geom_point(mapping = aes(x = Temp, y = Wind))
# option 3:
ggplot(data = airquality, mapping = aes(x = Temp))+
geom_point(mapping = aes(y = Wind))
```

In this example, it does not matter whether the aesthetics are defined inside `ggplot()` and/or in `geom_point()` since the resulting plot does not change. In contrast to that, when we define another variable in the `geom()`-function (e.g. `y = Solar.R`) although we have already defined a y-variable in `ggplot()` (e.g. `y = Wind`), the variable `Wind` will be overwritten by the variable `Solar.R`. The y-axis is called `Wind` in figure \@ref(fig:ggplot-hierarchy), but that is not true any longer. So, we have to adjust the labeling (see figure \@ref(fig:ggplot-hierarchy-label)).

```{r ggplot-hierarchy, fig.cap="(ref:ggplot-h-l)"}
ggplot(data = airquality, mapping = aes(x = Temp, y = Wind))+
 geom_point(aes(y = Solar.R))
```

(ref:ggplot-h) Scatterplot of solar radiation vs. temperature although the y-axis is called `Wind` since the y-variable has been overwritten.

```{r ggplot-hierarchy-label, fig.cap="(ref:ggplot-h-l)"}
ggplot(data = airquality, mapping = aes(x = Temp, y = Wind))+
 geom_point(aes(y = Solar.R))
```

(ref:ggplot-h-l) Figure \@ref(fig:ggplot-hierarchy) with labeling. 

Dependent on the number of variables and their scale of measurement (discrete, continuous) the `ggplot2` Cheatsheet [@ggplot2Cheatsheet] shows which `geom()_*`-function(s) to use. The `stat_*()`-function(s) work similarily as the `geom()_*`-functions (`stat_*()`- and `geom_*()`-functions are equivalents), e.g.
    
```{r, eval=FALSE}
geom_bar(stat = "count") # is equal to
stat_count(geom = "bar")
```

```{r, fig.height=3, echo=TRUE, eval=FALSE}
ggplot(data = airquality, mapping = aes(x = Temp, y = Wind))+
  geom_point(stat = "identity") # stat = "identity" by default
# is equal to
ggplot(data = airquality, mapping = aes(x = Temp, y = Wind))+
  stat_identity(geom = "point") # geom = "point" by default
```

Here are some of the `stat_*()`- and `geom_*()`-function equivalents based on [@Arnold2020]:


`geom`    | `stat`
----------|------------------
`geom_bar()` | `stat_count()`
`geom_bin2d()` | `stat_bin_2d()`
`geom_boxplot()` | `stat_boxplot()`
`geom_contour()` | `stat_contour()`
`geom_count()` | `stat_sum()`
`geom_density()` | `stat_density()`
`geom_density_2d()` | `stat_density_2d()`
`geom_hex()` | `stat_hex()`
`geom_histogram()` | `stat_bin()`
`geom_qq_line()` | `stat_qq_line()`
`geom_qq()` | `stat_qq()`
`geom_quantile()` | `stat_quantile()`
`geom_smooth()` | `stat_smooth()`
`geom_violin()` | `stat_violin()`
`geom_sf()` | `stat_sf()`


Based on this introduction of ggplots, we can easily reconstruct the plots we created in base-R (see chapter \@ref(plotsbaseR)).

Based on this introduction of ggplots, we can easily reconstruct the plots we created in base-R (see chapter \@ref(plotsbaseR)).
Before we do that, it is recommended to save the variables in a data frame:
```{r}
x <- seq(from = -8, to = 8, by = 0.1)
y <- dnorm(x = x)
y2 <- dnorm(x = x, mean = -1)
y3 <- dnorm(x = x, mean = 2)
nd <- data.frame(x, y, y2, y3)
head(nd)
```

Then, the single curves are added to the ggplot by adding layers (for each curve one layer) to the plot. Here, `geom_line()` is used to visualize the curves in form of lines. Furthermore, the following code chunk shows that the lines are colored by defining the argument `color` **outside** `aes()`.

```{r ggplot-normal-distrib, fig.cap="(ref:ggplot-nv)"}
ggplot(data = nd, mapping = aes(x = x))+
  geom_line(mapping = aes(y = y), color = "blue", size = 2, linetype = "dotted")+
  geom_line(mapping = aes(y = y2), color = "#7FFF00")+
  geom_line(mapping = aes(y = y3), color = "yellow")+
  ggtitle("Normal distribution - density")
```

(ref:ggplot-nv) Density functions for the normal distribution with $\mu_1 = 0$, $\mu_2 = -1$ and $\mu_3 = 2$.

Instead of adding each density function to the plot by calling `geom_line()` several times, it is possible to add all curves to the plot by calling `geom_line()` only one time.
For this, we have to modify the data set. We just want to call the `x` variable (x values) and the `y` variable (the density values of each curve) and color the values by the name of the curve (`y`, `y2` and `y3`). This is achieved by *lengthens*  the data set:

```{r}
nd2 <- data.frame(x = rep(x, times = 3), density=c(y, y2, y3),
                  curve = c(rep("y", times = length(y)), rep("y2", times = length(y)),
                            rep("y3", times = length(y))))
 head(nd2, n = 20)
```

In the first column, the `x` values are repeated three times (for curve `y`, `y2` and `y3`). The second column consists of the density values of curve `y`, `y2` and `y3` and the last columns assigns the name of the curve to each value. Consequently, the data set `nd2` has three times more rows than `nd` has:

```{r}
nrow(nd)
nrow(nd2)
```

The code to reproduce figure \@ref(fig:ggplot-normal-distrib) is shortend:

```{r ggplot-normal-distrib2, fig.cap="(ref:ggplot-nv2)"}
ggplot(data = nd2, mapping = aes(x = x, y = density, color = curve))+
  geom_line()
```

(ref:ggplot-nv2) Density functions for the normal distribution with $\mu_1 = 0$, $\mu_2 = -1$ and $\mu_3 = 2$.

Now, the three curves are not colored by defining `color` outside `aes()`. Instead, `color` is defined **inside** `aes()` since we have called a **variable** (named `curve`). So, we can conclude from that: 

+ Single lines, points, etc. are colored by defining the aesthetics arguments **outside** `aes()`.

+ Coloring a variable's values by its categories (here: the curves' names (`y`, `y2` and `y3`)) is achieved by assigning the variable's name to the `color` argument **inside** `aes()`.

It the latter case, a legend will be automatically added (see figure \@ref(fig:ggplot-normal-distrib2)).

A smart solution to *lengthens* the data set - instead of using `rep()` - is provided by `pivot_longer()` from `tidyr`-package created by @tidyr:

```{r}
nd2 <- nd %>% pivot_longer(cols = c(y, y2, y3)) # columns y, y2 and y3 are concatenated 
# to form one column, the other columns have been adjusted automatically
head(nd2)
colnames(nd2) <- c("x", "curve", "density")
```

Based on the data set `nd2`, it is now easy to fill curves by calling `fill = curve` **inside** `aes()` (analogous to the argument `color`) and using `geom_polygon()` where `alpha` stands for the *degree* of opacity:

```{r}
ggplot(data = nd2, mapping = aes(x = x, y = density, fill = curve))+
  geom_polygon(alpha = 0.4)+
  scale_fill_discrete(name = "Density", labels= c(latex2exp::TeX("$\\mu=0, \\sigma=1$"), 
  latex2exp::TeX("$\\mu= -1, \\sigma=1$"), latex2exp::TeX("$\\mu=2, \\sigma=1$")))
```

As we have already seen in chapter \@ref(baseRplot), the package `latex2exp` is used to customize the legend inside `scale_fill_discrete()` [@ggplot2Cheatsheet].

## Histograms and boxplots

The creation of histograms in `ggplot2` is allowed by the geom `geom_histogram()` which is exemplarily applied to the wind speed and temperature of the `airquality` data set [@R]. The arrangement of ggplots (on top of each other, side by side, ...) is achieved by using an extra R package called `gridExtra` [@gridExtra]:

```{r}
g1 <- ggplot(data = airquality)+
  geom_histogram(mapping = aes(x = Wind))
g2 <- ggplot(data = airquality)+
  geom_histogram(mapping = aes(x = Temp), binwidth = 5)
grid.arrange(g1, g2, ncol = 2) # arrange both histograms in one row
```

Since the two boxplots have been assigned to `g1` and `g2`, respectively, again, information can be received by applying `ggplot_build()`:

```{r}
ggplot_build(g2)$data
```

where

+ `count` describes the number of points (values) in the bin,

+ the intervals of the single bins are defined as (`xmin`, `xmax`] which is the `binwidth` (Since we have defined `binwidth = 5`, all intervals have the same size (5).),

+ `x` is the center of the interval and

+ much more information.

```{r}
typeof(ggplot_build(g2))
```

Instead of defining the `binwidth` we can specify the number of bins (argument `bins`), e.g.:

```{r}
g2 <- ggplot(data = airquality)+
  geom_histogram(mapping = aes(x = Temp), bins = 10)
```

Then, the number of rows in 

```{r}
ggplot_build(g2)$data[[1]]
```

is equal to `bins = 10`.

The creation and examination of boxplots works similarily:

```{r}
g1 <- ggplot(data = airquality)+
  geom_boxplot(mapping = aes(x = Wind)) + labs(x = "Wind [mph]")
g2 <- ggplot(data = airquality)+
  geom_boxplot(mapping = aes(x = Temp)) + labs(x = "Temperature [°F]")
grid.arrange(g1, g2, ncol = 2)
```

The boxplots can be *flipped* by using `coord_flip()` the following way:

```{r}
g1 <- ggplot(data = airquality)+
  geom_boxplot(mapping = aes(x = Wind)) + labs(x = "Wind [mph]")+
  coord_flip() # flip coordinates
g2 <- ggplot(data = airquality)+
  geom_boxplot(mapping = aes(x = Temp)) + labs(x = "Temperature [°F]")+
  coord_flip() # flip coordinates
grid.arrange(g1, g2, ncol = 2)
```

Again, the data of the boxplot can be accessed as we already know:

```{r}
boxplot_g1 <- ggplot_build(g1)$data[[1]]
typeof(boxplot_g1)
str(boxplot_g1)
boxplot_g1
```

Consequently, the outliers are extracted by:

```{r}
boxplot_g1$outliers
```

Based on `boxplot_g1` *interesting* values can be marked:

```{r}
wind_boxplot <- ggplot(data = airquality)+
  geom_boxplot(mapping = aes(x = Wind), outlier.colour = "orange")+ # coloring outliers
  geom_segment(data = boxplot_g1, mapping = aes(x = xmiddle, xend = xmiddle,
                                                y = ymin, yend = ymax), colour = "chocolate")+ # ymin, ymax: coordinates of box
geom_text(x = 9.2, y = -0.35, label = paste(boxplot_g1$xmiddle), color = "chocolate")+
  theme(axis.title.y = element_blank()) # remove title of y-axis
wind_boxplot # call the defined boxplot
```

**Question(s):**

> Which values have been marked in the previous boxplot (figure xx)? 


## Interactive plots with `plotly` [@plotly]


```{r, echo=TRUE, eval=FALSE}
air_lm_ggplot <- ggplot(data = airquality, mapping = aes(x = Temp, y = Wind))+
geom_point()+
geom_smooth(method = "lm", se = FALSE)
ggplotly(air_lm_ggplot) # converts ggplot2 to a plotly object
```

```{r ggplotly-air-lm, fig.cap = "(ref:ggplotly-air-lm)", echo=FALSE}
knitr::include_graphics("gfx/ggplotly_air_lm.png")
```

(ref:ggplotly-air-lm) Two-dimensional plot (`plotly` object) based on `air_lm_ggplot`.


```{r, eval=FALSE}
plot_ly(airquality, x = ~Temp, y = ~Wind, z = ~Solar.R) %>%
  add_markers(color = ~Month)
```

```{r, plotly-airquality, echo=FALSE, fig.cap = "(ref:plotly-3d)"}
knitr::include_graphics("gfx/plot_ly_airquality.png")
```

(ref:plotly-3d) Three-dimensional plot (`plotly` object) based on `datasets::airquality` [@R].


