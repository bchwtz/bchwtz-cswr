[["index.html", "Computational Statistics Prerequisites", " Computational Statistics Benjamin Buchwitz 2021-01-06 Prerequisites This is now a private REPO! This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports, e.g., a math equation \\(a^2 + b^2 = c^2\\). The bookdown package can be installed from CRAN or Github: #install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) Remember each Rmd file contains one and only one chapter, and a chapter is defined by the first-level heading #. To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.name/tinytex/. "],["intro.html", "Chapter 1 The Basics", " Chapter 1 The Basics All of my friends who have younger siblings who are going to college or high school - my number one piece of advice is: You should learn how to program. – Mark Zuckerberg "],["r-and-the-r-project.html", "1.1 R and the R-Project", " 1.1 R and the R-Project R is a language and an environment for statistical computing and graphics. It is a GNU project that is similar to the S language and environment, which was developed at Bell Laboratories (formerly AT&amp;T, now Lucent Technologies) by John Chambers and his colleagues. R can be considered a different implementation of S. There are some important differences, but much code written for S runs unaltered under R. R provides a wide variety of statistical (linear and nonlinear modeling, classical statistical tests, time-series analysis, classification, clustering, …) and graphical techniques, and is highly extensible. The S language is often the vehicle of choice for research in statistical methodology and R provides an Open Source way to participate in that activity. "],["r-system-and-rstudio.html", "1.2 R System and RStudio", " 1.2 R System and RStudio RStudio is an integrated development environment (IDE) as well as a graphical user interface (GUI) for R. It includes a console, a syntax-highlighting editor that supports direct code execution as well as tools for plotting, debugging and workspace management. When you start RStudio for the first time it should look like this: Figure 1.1: RStudio The shown version of RStudio is 1.1.x, which was the latest one available when this script was written and revised. If you have not changed any of the default settings, your RStudio should look almost the same. The most important section is the big one on the left (1). This is the R console that connects your development environment with the R core. RStudio makes it simple, interactive and very convenient to use R. You just type your command into the bottom line of the console tab (1), hit Enter and your computer will execute it. Commands are your way to talk to the computer and that is why the console is often also called the command line interface (CLI). The &gt; is called the prompt and indicates that R is ready and waiting for your commands. If you type 1 + 2 into the command line, you should see the following after hitting Enter: 1 + 2 ## [1] 3 As we want reproducible results we need a more convenient and supporting place to work with our code. Scripts allow us to be an efficient programmer. Therefore you should bundle and work with your code in the Script Pane (2) and stop typing in the console. You can easily start a new script by clicking File \\(\\to\\) New File \\(\\to\\) R Script in the main menu bar. Or you hit Control + Shift + N (Windows) on the keyboard to open one automatically. As you can see R responds to your request with more than just the result. The [1] on the left side indicates that the line in which the response is written starts with the first value. This becomes quite useful when your commands become more complex so that R returns multiple values. The colon operator (:) creates a sequence between two given numbers by incrementing the first number by 1 (or -1 respectively if the bigger number is provided as the first argument) until the second number is reached. If we want R to give back the integers between 1 and 100 we simply type1:100 and get exactly what we have asked for: 1:100 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 The numbers in brackets now indicate that the first line starts with the first value of R’s answer to your command and the second line starts with a higher value (depending on the size of your RStudio window). When handling matrices and bigger vectors in your programs you will greatly appreciate this small feature, but for now, we can ignore it. To make the next lines of R code more readable this formatting is only referred to when I want you to notice them. The same applies for the &gt; at the beginning of each line. Therefore the following Code excerpts will not contain these signs, which will make it also much easier for you to copy them into your own console. To clearly differentiate between commands and responses I will indicate R’s output with R&gt; and color them differently so that our first example will look like this: 1 + 2 ## [1] 3 "],["first-steps-r-as-calculator.html", "1.3 First Steps: R as Calculator", " 1.3 First Steps: R as Calculator R is a powerful programming language for statistical algorithms and therefore you can also use it as a (very powerful) calculator for nearly every case you can imagine including calculations on arrays and complex matrix operations. Let us start with some basic examples: 3 + 5 * 2 ## [1] 13 R handles the sharp (hash) # symbol as an indicator for comments and in fact does not interpret it. You can and should (!) use it to comment on your code to express your thoughts and what you were trying to do while programming because it is necessary to understand your code. But let’s stay focused: 4 * -(5 - 1,5) ## Error: &lt;text&gt;:1:12: unexpected &#39;,&#39; ## 1: 4 * -(5 - 1, ## ^ Errors occur while programming. One of the major sources of errors is the syntax of a language. Syntax simply describes the required structure for commands. Every command has to follow certain structural rules in order to make R understand what you want it to do. In this case, R is designed to accept the point as decimal separator, otherwise, it will only prompt an error message while providing a short hint to the problem. You can then just retype the command or you can use the arrow-up key \\(\\uparrow\\) on your keyboard to access your last command and change it accordingly: 4 * -(5 - 1.5) # The changed command works. ## [1] -14 As stated before, with R you can do everything your calculator can do, from simple mathematical operations to more complex tasks. Some well known and often used functions are: 10 / 2 # Simple division ## [1] 5 5^2 # Exponentiation ## [1] 25 pi # Mathematical constant Pi ## [1] 3.141593 sin(pi / 6) # Trigonometry ## [1] 0.5 sqrt(64) # Square root ## [1] 8 sqrt(as.complex(-64)) # Complex square root ## [1] 0+8i log(1) # Natural logarithm (base e) ## [1] 0 sum(1:6) # Sum of numbers from 1 to 6 ## [1] 21 1:6 + 1:6 # Element-wise addition ## [1] 2 4 6 8 10 12 prod(1:3) # Product of multiple elements ## [1] 6 Trying to calculate something that is not defined, leads to a warning. If you try dividing by zero, R reminds you that it has no answer to this question as well as any other calculator. 0 / 0 # Not defined, NaN = Not a Number ## [1] NaN "],["objects-and-data-structures.html", "1.4 Objects and Data Structures", " 1.4 Objects and Data Structures You may have heard of objects or the concept of object-oriented programming. R is also considered to be object-oriented, which basically means that we have to deal with objects if we want to use it. You can imagine an object as a name that you can use to refer to stored data. Of course, there are rules for naming an object. Generally speaking, every symbol is possible as long as it consists of alphanumerical characters, numbers, and dots. Special characters like $, @, +, -, / or * are not allowed within names. To assign values to an object, we use the arrow &lt;-. Whenever you tell R to handle commands containing your object, it will replace it with the data saved inside. The most basic form of an object is a variable, containing only one value: foo &lt;- 5 # Arrow consists of &lt; (less than) and - (minus) foo ## [1] 5 RStudio will support you with multiple features that make your life as a programmer easier. If a new variable is generated, it will show you a sneak peek of its contents in the environment pane on the upper right corner. The environment pane (3) will show you all objects, you have created since starting RStudio. Variable or object names are case sensitive, which means that R differentiates between small and capital letters. Two objects with the same name, but different capitalization are regarded as two different objects: foo &lt;- 5 # Variable assignment Foo &lt;- 3 FOO &lt;- 1 foo + 1 # Variable evaluation ## [1] 6 Foo + 1 ## [1] 4 FOO + 1 ## [1] 2 As a practical proof that different capitalization produces different objects, we can also use R to compare the created objects. You can simply do this by using == as a comparison operator. Watch out, do not forget the second equality sign. When using only one, your command will be interpreted as an assignment and has, therefore, the same effect as using &lt;-. Although one equality sign can be used as an assignment operator, it should be avoided due to better readability of your code: foo == foo # Check for equality (==) ## [1] TRUE Foo == FOO ## [1] FALSE foo = FOO # Do not use &quot;=&quot; to assign values! foo # Using &quot;&lt;-&quot; is much better to read. ## [1] 1 Using variables in mathematical operations does not change their values. To change stored data, you have to overwrite it. R will do this without asking for your permission. To remove a variable completely from the memory you can use the function rm(). foo &lt;- 5 # Assign a value foo # Display assigned value ## [1] 5 foo &lt;- 20 # Overwrite the value foo ## [1] 20 rm(foo) # Remove/delete variable foo 1.4.1 Data Structure: Vectors Of course, we are not limited to storing simple numbers in R. In fact, there is no specialized data type for storing single numbers as in other programming languages. Stored single numbers are often called atomic vectors or one-element vectors. However, vectors can easily be used to store multiple numbers. foo &lt;- 1:6 # Create vector foo foo ## [1] 1 2 3 4 5 6 vec &lt;- c(0.5, 1, 2) # Combine values into a vector vec ## [1] 0.5 1.0 2.0 foo - 1 # Using vectors in calculations ## [1] 0 1 2 3 4 5 foo * foo # Equal to foo? ## [1] 1 4 9 16 25 36 # Watch out when using vectors foo + 1:3 # with different lengths! ## [1] 2 4 6 5 7 9 foo + 1:5 # Recycling ## Warning in foo + 1:5: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 10 7 As you may have noticed R does not follow the rules of matrix multiplications but uses element-wise execution instead. This means that R is applying the requested operation to each and every element of the vector. When multiplying two vectors of the same length R will always multiply the first element of the first vector with the first element of the second vector, then the second element of the first vector with the second element of the second vector and so on. When given two vectors of different length R will repeat the shorter vector until it matches the length of the longer one. Note that the shorter vector will only be repeated within this single calculation, R does not change the vector itself. If the length of the shorter vector is not a natural multiple of the length of the long one, R will perform a calculation by concatenating the shorter vector multiple times, until it reaches the same length as the longer one, and issues a warning with the calculation results. This behavior is called vector recycling. Element-wise operations are very useful, especially when it comes to handling data with a lot of observations. You can easily apply calculations which will only affect elements from the same observation when using vectors with the same length. If you want to know the length of a vector you can use the function length(). 1.4.2 Data Structure: Matrices Even though element-wise operations are useful sometimes you need matrix-algebra in your functions and R does of course support this, but there are special operators you have to use. There are different operators for every case you may need. You can, for example, calculate the inner product with the %*%-Operator and the outer product with the %o%-Operator. vec &lt;- 1:3 # Create vector vec length(vec) # Ask for length of vec ## [1] 3 vec2 &lt;- vec * vec # Element-wise multiplication vec2 ## [1] 1 4 9 scalar &lt;- vec %*% vec # Calculate inner product scalar ## [,1] ## [1,] 14 mat &lt;- vec %o% vec # Calculate outer product, same as vec %*% t(vec) mat # R indicates rows and ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 2 4 6 ## [3,] 3 6 9 # columns for you When manipulating data, it may be useful to access specific columns, rows or elements of a matrix. You can simply use the row and column indices in brackets object[row, column] to access the desired data. Leaving one spot blank advises R to return all elements in this dimension. If you need to know the \\(n \\times m\\) dimensions of the matrix you can use dim() to get to know what you need. dim(mat) # Request matrix dimensions ## [1] 3 3 mat[1 , 1] # Accessing first element in first row ## [1] 1 mat[2 , ] # Second row of a matrix ## [1] 2 4 6 mat[ , 3] # Third column of a matrix ## [1] 3 6 9 The most common way of creating matrices is using the command matrix which takes an arbitrarily long vector and input. Obviously, you need to define the number of rows and columns for the matrix. By default, all the elements from the vector are filled into the matrix column by column. To change the standard behavior we can set the argument byrow = TRUE. matrix(1:9, nrow = 3, ncol = 3) # Filling matrix by column ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE) # Filling matrix by row ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 You can also construct matrices out of vectors manually using rbind() for row vectors and using cbind() for column vectors. Transposing a matrix can be done with t() and calculating the determinant with det(): rowMat &lt;- rbind(vec, vec, vec) # Matrix with vec as row vector rowMat ## [,1] [,2] [,3] ## vec 1 2 3 ## vec 1 2 3 ## vec 1 2 3 colMat &lt;- cbind(vec, vec, vec) # Matrix with vec as column vector colMat ## vec vec vec ## [1,] 1 1 1 ## [2,] 2 2 2 ## [3,] 3 3 3 det(colMat) # Determinant of colMat ## [1] 0 As we have already talked about comparison operators and element-wise operations it is not surprising that there are similar operations for matrices and matrix elements. rowMat == t(colMat) # Element-wise matrix comparison, transpose colMat ## [,1] [,2] [,3] ## vec TRUE TRUE TRUE ## vec TRUE TRUE TRUE ## vec TRUE TRUE TRUE identical(rowMat, t(colMat)) # Matrix comparison ## [1] TRUE The function all.equal() seems to be an alternative to identical() as it returns the same value for our matrix comparison. But of course, there is a reason that both of these functions exist. This has to do with the internal representation of numeric values and we are going to talk about this in more detail in the next chapter. 1.4.3 Data Structure: Strings Data is more than just numbers and so there is a need for a structure specialized in storing sentences, words and characters, which are called strings. You can create string variables in the same way as vectors and matrices, but you need to place single or double quotation marks at the begin and end of each string. x &lt;- c(&quot;We&quot;,&quot;love&quot;) # Create variable containing two strings. x ## [1] &quot;We&quot; &quot;love&quot; y &lt;- &quot;statistics&quot; # Variable with only one string. y ## [1] &quot;statistics&quot; length(y) ## [1] 1 The universal length() function can also be used with string variables and it will give you the number of strings it contains and not the numbers of characters. There are many other commands for string variables e.g. dealing with putting strings together or taking them apart. The squared brackets we got to know when discussing vectors can also be used to access elements of a string. nchar(y) # Number of characters in the variable ## [1] 10 nchar(x) # Number of characters per element ## [1] 2 4 sentence &lt;- c(x, y) # Combining strings in a variable sentence ## [1] &quot;We&quot; &quot;love&quot; &quot;statistics&quot; sentence[3] # Access the third element ## [1] &quot;statistics&quot; 1.4.4 Data Structure: Lists and Data Frames Lists allow more complex combinations of different data types. You can see a list as a vector which can contain elements of different data types without losing information about their nature. Every sub-element in a list has an own name, like any variable or any object and can be accessed using the dollar sign $ as operator. list &lt;- list(num=1:3 , strg= &quot;abc&quot;) # Create a list with 2 elements list # Display the list ## $num ## [1] 1 2 3 ## ## $strg ## [1] &quot;abc&quot; list$num # Display element num within list ## [1] 1 2 3 str(list) # Overview over structure of the list ## List of 2 ## $ num : int [1:3] 1 2 3 ## $ strg: chr &quot;abc&quot; The str() command is a comfortable way of getting a quick overview of the data structure and it’s containing values of an object. It is a generic function and also works with other data structures such as simple vectors, much more complex data frames or even functions. Data frames are a specific incarnation of lists and ideal when working with larger data sets, as they allow us to combine all sorts of data in them, which won’t work well in a normal list and won’t work at all in a matrix. Each sub-element of the data frame is handled as its own column in our matrix-like structure of data. All sub-elements need to have the same length and each sub-element needs to be consistent in terms of its data type, which results in a data frame with exactly one datatype per column and a fixed number of rows for all columns. df &lt;- data.frame( Name=c(&quot;Homer&quot;,&quot;Marge&quot;,&quot;Bart&quot;,&quot;Lisa&quot;), Age=c(38 , 34 , 10 , 8), Sex=c(&quot;m&quot;,&quot;f&quot;,&quot;m&quot;,&quot;f&quot;), stringsAsFactors = FALSE) df # Display the data frame ## Name Age Sex ## 1 Homer 38 m ## 2 Marge 34 f ## 3 Bart 10 m ## 4 Lisa 8 f df$Name # Display only column with names ## [1] &quot;Homer&quot; &quot;Marge&quot; &quot;Bart&quot; &quot;Lisa&quot; "],["functions.html", "1.5 Functions", " 1.5 Functions 1.5.1 Using Functions Programming reveals its value when bringing data and algorithms together. We already briefly talked about the different data storing concepts, now it is time to talk about “containers” for our algorithms, which we are going to call functions. We already encountered some basic functions like sum(), sqrt() and det(), which allow us to perform basic tasks with our stored data. The base version of R includes many other and much more powerful functions, even more can be added by installing extensions, called packages, from the internet. And of course, we can write functions on our own. A function is always defined by its name followed by a list of arguments or parameters. Most functions return a value, which can be a number, a matrix or a list. Using a function is pretty straightforward: just type in the name followed by parentheses with the data you want the function to use. Arguments can be numbers, vectors or even the output from other functions. This ability to handle the output of a function directly as an input for another function allows us to nest functions, which is also called linking. round(pi) ## [1] 3 mean(df$Age) ## [1] 22.5 round(mean(df$Age)) ## [1] 22 Functions can handle multiple arguments as input. This allows us to specify what we want and handle different cases within the same function. But first we need to know the different arguments a function can accept - and of course, there is a function to find out about that. This function is called args(). As input, it accepts the function that you want to know the arguments of. args(round) ## function (x, digits = 0) ## NULL round(pi, digits=2) ## [1] 3.14 round(pi, length=2) #causes an error ## Error in round(pi, length = 2): unused argument (length = 2) When using arguments not listed in the output of args(), it is quite obvious that the function can’t handle such input and produces an error. All listed arguments can be used just by assigning a value while calling the function, as it’s done above with the argument digits=2. The function works also when we do not provide a value for digits and that is why this argument is called optional. Optional arguments always have a default value like digits=0 for the function round(). Therefore, only the input to be rounded x is mandatory, so that you can not call round without providing a value for it. The majority of functions is able to accept multiple arguments as input and there are multiple ways to pass them over, meaning you can explicitly name the arguments and assign the data to them using the =. This allows you to completely mix up the order of the arguments. Alternatively, you can pass them to the function in the right order without directly naming or addressing them. In general, it is good practice to name each argument as this keeps your code clean and understandable. num &lt;- c(0.5, 0.25, 0.125, 0.0625) # Some arbitrary numbers round(x = num, digits = 2) # Function-call with named arguments ## [1] 0.50 0.25 0.12 0.06 round(digits = 2, x = num) # Function-call with mixed up named arguments ## [1] 0.50 0.25 0.12 0.06 round(num,2) # Function-call with unnamed arguments ## [1] 0.50 0.25 0.12 0.06 round(2, num) # Watch out! Using unnamed arguments ## [1] 2 2 2 2 # can lead to unintended results. For some reason, people who are new to programming, feel the need to clean up the console window. As there is no real-world need for this, there is not an easy to remember command, but if you are one of those people who like it really tidy, the next example is for you: cat(&quot;\\014&quot;) # Removes all content from console window In RStudio you can also use CTRL + L when you have placed the cursor in the console pane to clear the output area or click Clear in the global environment window. 1.5.2 Writing Functions Programming is applied problem-solving. To start with our own function, we need a problem to solve with our newly learned R skills. And here it is: Write a function named roll() that simulates rolling a pair of dice. To implement rolling a dice you may want to use the function sample() as the heart of your program. At first, we need the numbers located on a die. Luckily, we already know how to produce them, so this isn’t a problem at all. Next thing is to get familiar with the sample() function. We can easily do this by using args() and playing a little bit around. num &lt;- 1:6 args(sample) ## function (x, size, replace = FALSE, prob = NULL) ## NULL sample(num) ## [1] 3 4 6 5 1 2 sample(num, size = 1) ## [1] 2 sample(num, size = 2) # Argument size allows us to adjust how ## [1] 6 3 # many times the dice are rolled Using sample() only with our vector of numbers does not lead to the correct result, but the argument size allows us to adjust for the number of times a dice is rolled. We obviously need two returned values as we need one value per die, so size=2. When you run this line of code over and over again you may notice that the two returned values are never the same. If we are trying to increase the number of rolled dice, R points us directly to the reason: # sample(num, size = 7) #causes an error sample(num, size = 2, replace = TRUE) ## [1] 5 3 The behavior of the sample()-function takes us directly back to one of our first statistics lessons. Every time the function returns a value it removes it from the population/sample, so it can not be returned again. If we set the option replace to TRUE the previously withdrawn number is placed back in the sample and can be drawn again. Therefore this option allows us to create independent, random samples, which is exactly what we want. We just solved our first programming problem! Now we just need to wrap our code in a function so that we can call it using roll(). For this we need the function function(). my_function &lt;- function() { } # This is how a function is defined # We can simply put our working example in the function constructor, # give it a name and execute everything by calling the given name. roll &lt;- function() { num &lt;- 1:6 dice &lt;- sample(num, size = 2, replace = TRUE) return(dice) } roll() # We can now use our function ## [1] 6 1 The code between the parentheses is called the body of a function. The complete code runs when you require R to execute your function. You can see how I indented these lines. This does not affect R’s behavior but makes the code a lot more readable. R ignores every blank line and space, so you can use them to structure your code. The return() at the end of the function advises R to explicitly give back a value. Code that does not produce an output on the console by running it line by line is called a silent function. If you perform a calculation that also produces an output on the console it will be automatically returned if its the last line in your function, e.g. sum(dice) instead of return(dice) would return the combined result of the two rolled dices. Let us have a look at an overview of all the different parts of a function: Figure 1.2: Function Constructor and Parts of a Function 1.5.3 Solving Problems Our small roll()-function already has most of the described parts of the function constructor except for default values - in fact, it does not require any values to run the function, which makes it very inflexible. While programming, it is always better to solve general problems instead of very narrowly defined cases. So let’s adjust our problem description a little and produce a program that is more flexible. Write a function named roll() that simulates rolling a desired number of dices and allows the user to adjust the number of sides on the rolled dice. To solve this exercise we can use our existing roll()-function and modify it to meet the desired criteria. All we have to do is define the dependencies of the sample()-function in the body arguments of the function constructor. While doing this we can also define useful default values, so that we can still use the function without arguments. Let us use rolling a six-sided pair of dice for the default values. Our improved roll()-function now looks like this: roll &lt;- function( num = 1:6 , rolls = 2) { dice &lt;- sample(num, size = rolls, replace = TRUE) return(dice) } This function is now much more general and usable for a lot of different cases. Let’s have a brief look at how to use it. To show that the function delivers the same value when we call it with arguments and default arguments, we have to fix the random number generator. R uses this random number generator in the background to pick a value from our sample and will, therefore, deliver different results each time we call our function. Luckily we can lock the random number generator for a single execution using the set.seed() command with a freely selected numeric value as argument. Every time a routine relies on the random number generator and the seed is set to the same value R will produce the same result. set.seed(1) # Fix the Random Number Generator roll() # Execute modified function ## [1] 1 4 set.seed(1) roll(num = 1:6 , rolls = 2) # Function call with default Arg. ## [1] 1 4 # It is easy to increase the number of rolls or the number of sides # of the rolled dice using the argument section of the function. roll(num = 1:18 , rolls = 5) ## [1] 7 1 2 11 14 To execute multiple lines of code at once you can simply select them and hit the Run in the upper right corner of RStudios script pane. "],["packages.html", "1.6 Packages", " 1.6 Packages 1.6.1 Packages with Data Of course, we don’t need to invent everything ourselves. R comes with tons of great functions we can use for our analysis. One of the most important tasks in statistics is to perform a linear regression with one dependent and one or more independent variables. Load the dataset wage1 into R and use the lm()-function to fit a linear model to the data and calculate the effect of education on wage in the simple bivariate case. Summarize and interpret your findings considering that the data was recorded back in the 1970s in the USA. Naturally, the first step is to load the required data set into R. Luckily the data is simply available as a package that can be installed with install.packages(\"wooldridge\"). After installation and loading the package with library(wooldridge) we can see the whole documentation including variable descriptions by typing ?wage1. library(wooldridge) # Load the dataset dim(wage1) # Dimensions of the table ## [1] 526 24 names(wage1) # Variable names in the dataset ## [1] &quot;wage&quot; &quot;educ&quot; &quot;exper&quot; &quot;tenure&quot; &quot;nonwhite&quot; &quot;female&quot; ## [7] &quot;married&quot; &quot;numdep&quot; &quot;smsa&quot; &quot;northcen&quot; &quot;south&quot; &quot;west&quot; ## [13] &quot;construc&quot; &quot;ndurman&quot; &quot;trcommpu&quot; &quot;trade&quot; &quot;services&quot; &quot;profserv&quot; ## [19] &quot;profocc&quot; &quot;clerocc&quot; &quot;servocc&quot; &quot;lwage&quot; &quot;expersq&quot; &quot;tenursq&quot; As we can see the whole data set includes 526 observations and 24 variables. To get a first impression of the data we can type View(wooldridge::wage1). This will produce a viewer tab which can be used to view and inspect the data. Although it looks like an editable spreadsheet, the data can only be viewed and not changed. If you want to modify data you have to go back to the script view or command line and use commands to do this. If you are familiar with tools to handle spreadsheets like Excel you may think of quickly editing the data set over there and return to R afterward. If this came to your mind, just stop thinking about it now! R is much more powerful and way quicker than Excel and its lookalikes, so there is really no reason to chop up your workflow. As we will only calculate a simple bivariate model we don’t need all the data, so we extract what we need from the big set. In our simple case, these are the columns wage containing the hourly average wages in USD of the interviewed individuals and educ their respective years of education. So we basically have to extract the first two columns from the data set. wage &lt;- wooldridge::wage1$wage # Extract wage data (hourly wage in $) education &lt;- wooldridge::wage1$educ # Extract education data (education in years) # Initial data inspection summary(wage) # Summarize the variable wage ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.530 3.330 4.650 5.896 6.880 24.980 summary(education) # Summarize the variable education ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 12.00 12.00 12.56 14.00 18.00 Extracting the needed columns from the data frame is easy. We already discussed the $-Operator, which allows us to address named parts of an object. After extracting the data and giving the variables comprehensive names, we should gain a condensed overview of what we are using for our analysis. The summary() command is a generic function which works for many types of data and responds with a useful summary depending on the input. In our case summary() returns typical descriptive measures. As we now have a first feeling of the data, we can construct our linear model using the lm()-function. lm(wage ~ 1 + education) # Perform bivariate regression ## ## Call: ## lm(formula = wage ~ 1 + education) ## ## Coefficients: ## (Intercept) education ## -0.9049 0.5414 When simply executing the lm()-function R only returns the parameter estimates. That is far too less to evaluate if the model is appropriate or if the estimated effects are significant. We can use the summary()-function again to gain a deeper understanding of what we have calculated and how our model looks like. For convenience and re-usability it makes sense to store the results in an own object. model.uni &lt;- lm(wage ~ 1 + education) # Store results in variable summary(model.uni) # Summarize the fitted model ## ## Call: ## lm(formula = wage ~ 1 + education) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.3396 -2.1501 -0.9674 1.1921 16.6085 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.90485 0.68497 -1.321 0.187 ## education 0.54136 0.05325 10.167 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.378 on 524 degrees of freedom ## Multiple R-squared: 0.1648, Adjusted R-squared: 0.1632 ## F-statistic: 103.4 on 1 and 524 DF, p-value: &lt; 2.2e-16 The summary view of the regression object model.uni gives us much more information than the lm()-function itself. This allows us to evaluate and interpret the model parameters as we have learned in our basic undergraduate statistic courses. 1.6.2 Packages with Functions There are thousands of functions in the R core, but sometimes this is not enough and you have the need to expand R’s functionalities. As you are not the only programmer out there many of the required additional functions already exist, written by users like you, professionals or professors all around the world. And they are giving them to you for free so that you can use them for any purpose you want. So before starting a new programming project always do proper research and look at what is already out there. Results from statistical works and analysis are often displayed using graphical tools. Producing plots of data to gain a quick aggregated overview of the data or using graphics to support your results is common, needed and useful. R is already equipped with tools to generate plots like plot() and hist() and RStudio makes them easy to use and comfortable to handle their outputs. An additional option that aims to produce strong, nice looking plots with less effort than the standard R toolset is the package ggplot2. Their creators state that the package “takes care of many of the fiddly details that make plotting a hassle (like drawing legends)”. It seems to be worth to add ggplot2 to our portfolio. We are looking at some basics and produce some nice plots here. But first, we need to install the package. As long as you are connected to the Internet it is quite easy to install new packages using the command line: install.packages(&quot;ggplot2&quot;) # Installing packages requires # a working internet connection That’s it, already. R takes care of the rest. It will visit the website, download the package and install it with all dependencies automatically and report the progress in the console. If you already know the name of a package and want to install it, you can do this by simply replacing the text in quotation marks. If you don’t know the packages name - we will discuss some resources besides your favorite search engine to find useful packages and additional help later. Before you can use the power of a freshly installed package you have to advise R to load the package (even if it is already installed). You can do this using the library()-function. If you are trying to execute a command from the package before loading it R will respond with an error. library(&quot;ggplot2&quot;) # Loads an already installed package into memory One of ggplot2’s most powerful functions is the ability to create quick (but nice looking) plots using qplot(). This is a generic function which produces its output dependent on its input, just like summary(). If you give qplot() a single vector it will produce a nice histogram, if you give it two vectors of equal length it will create a scatter plot. sample &lt;- rnorm( 1000 ) # Generate 1000 norm. dist. numbers head(sample, 10) # Preview the first 10 numbers ## [1] -1.539950042 -0.928567035 -0.294720447 -0.005767173 2.404653389 ## [6] 0.763593461 -0.799009249 -1.147657009 -0.289461574 -0.299215118 qplot(sample , binwidth = .1) # Plot generated sample as histogram As you can see, it is very fast forward to generate nice histograms out of single vectors. The argument binwidth = .1 defines the width of each cluster to aggregate the generated values into pillars. As you may have noticed I have not written 0.1. Lazy programmers (and who isn’t?) can get rid of the leading zero and start floating point numbers with the dot. Please notice that your histogram may look a little different as rnorm() also relies on the internal random number generator and of course you can use the function hist() instead to produce a similar plot. We will dive deeper into random numbers and distributions in one of the following chapters. Let’s try out what happens if we give qplot() two vectors. x &lt;- seq(-5, 5, by = .1) y &lt;- x^2 qplot(x,y) # Plot using ggplot2-package plot(x,y) # Plot using R&#39;s core function "],["getting-help.html", "1.7 Getting Help", " 1.7 Getting Help 1.7.1 Integrated Help System The flexible package system has a lot of advantages and puts the mind power of world-leading data scientists directly to your fingertips. When installing a new package or adding a new function which has been developed either by the R Core Team or by another developer you need to use the documentation to get used to the new functions, what they are doing in detail, how the package is used and what overlaps and problems might occur. This is exactly the reason why R has a build in help system. You can get useful information about every function you have at hand. Just place the question mark in front of the function name and hit enter or use the more formal function help(). # This is how to help yourself and find out how new or existing # functions work. Always read the help page before asking someone! help(sin) # Load documentation for a function ?sin # Shortcut to help() help(package=ggplot2) # Information about whole package A help page consists of different sections, each discussing a special aspect of the function. While the exact parts of a help page vary due to different purposes of different functions the following list is not exhaustive for all functions, but you can expect to see at least the following sections: Description: Provides a brief overview of what the function actually does or what it was intended to do. This section allows you to quickly grasp if the function is useful for your intended case. Usage: Shows a very short function call, often just enough to see required arguments. It’s good to get easy functions to work, for more advanced applications look at the dedicated example section. Arguments: Explains the arguments used or required by a function and gives an overview of the needed datatypes or in what way an argument manipulates the behavior of a function. Details: Provides background information on the behavior of the function and often mentions or briefly explains the theoretical concept underlying the function. Examples: Often the second focal point after the description section. This section provides working code examples which show in more or less detail how the function could be used in practice. Especially the combination with other functions and creation of sample data is a good source of inspiration for your own projects. If you don’t know what the exact name of a function is you can use the help.search()-function to search for a keyword in the whole documentation. The question mark shortcut for this search function is ?? and it’s automatically suggested by R if it can’t find the function you were looking for. 1.7.2 Help on the Internet R has a gigantic global supporter and fan base. Therefore you can find a lot about solving special problems, handling errors or information about packages by simply searching the web. Sometimes it may be difficult to search something related to R as R is at least to some people also the \\(18^{th}\\) letter of the alphabet and this may be confusing for your favorite search engine. Here are a few starting points which may help you on your programming journey: www.rseek.org www.stackoverflow.com www.r-project.org/mail.html "],["exercises.html", "Exercises", " Exercises EX 1 Write a function that outputs your name on the command line and generates an output similar to the one shown below. Maximiliane Mustermann EX 2 Install the forecast package, load it and use one arbitrary function from the package. EX 3 Write a function that generates an output similar to the one shown below. Hello world! (And all the people of the world) EX 4 Write a function that generates an output similar to the one shown below. * *** ***** ******* ********* * EX 5 Write a function that takes two numbers as arguments and outputs their respective sum. "],["data-types.html", "Chapter 2 Data Types", " Chapter 2 Data Types There are only 10 types of people in the world: those who understand binary, and those who don’t. – Anonymous We already talked about different data structures like vectors, matrices and data frames we can use in R. Now it’s time to dig a little deeper and strengthen our understanding of more basic data organization concepts before we come back to data types, high-level data structures and how to work with real-life data in R. "],["fixed-and-floating-point-number-representation.html", "2.1 Fixed and Floating Point Number Representation", " 2.1 Fixed and Floating Point Number Representation Before we look at the actual data types lets get a bit technical and explore how computers deal with numbers. The numbers we normally use are called decimal numbers, which are basically numbers with a base of \\(b = 10\\). Thus, we can deconstruct any real number \\(x \\in \\mathbb{R}\\) into an (infinite) sum of powers to our base \\(b\\). Let’s look at an example: \\[ 42.125 = x = 4 \\cdot 10^{1} + 2 \\cdot 10^{0} + 1 \\cdot 10^{-1} + 2 \\cdot 10^{-2} + 5 \\cdot 10^{-3}\\] While numbers in the decimal system can be conveniently processed by humans, computers work differently. In order to store them in memory, we have to perform a base switch with our chosen number \\(x\\) and rewrite it in binary notation, where \\(b = 2\\) and therefore only the digits 0 (absence of electrical current) and 1 (presence of electrical current) exist. We know that \\(42.125 = 32 + 8 + 2 + 0.125\\), which leads to the following: \\[ 42.125 = x = 1 \\cdot 2^{5} + 0 \\cdot 2^{4} + 1 \\cdot 2^{3} + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 0 \\cdot 2^{0} + 0 \\cdot 2^{-1} + 0 \\cdot 2^{-2} + 1 \\cdot 2^{-3} \\] When we write the digits down it becomes clear that \\(42.125_{b = 10}\\) equals \\(101010.001_{b =2}\\). The representation we just discussed is called fixed point representation. Computers use a very similar version to handle real numbers called floating point representation. This is a combination of storing the algebraic sign, numbers in the binary system and moving the ‘decimal’ point while storing how many digits it has been moved and storing the algebraic sign. After this deconstruction our chosen number \\(x\\) in the decimal system looks like this: \\[ 42.125 = x = (-1)^{0} \\cdot 4.2125 \\cdot 10^{1}\\] All we have to do now is convert everything in binary again. For compatibility purposes we also need to come up with a standard, meaning how many binary digits (bits) we want to use for the sign, the actual number, and the exponent. The usual convention is 32 bit for single precision numbers divided into 1 bit for the sign, 8 bits for the exponent and 23 bits for the actual number (called mantissa) the convention for double precision numbers 64 bit with 1 bit for the sign, 11 bits for the exponent and 52 bits for the mantissa. By only having a fixed amount of bits to form a number it should be obvious that using such a coding comes at a cost. This cost is usually precision. The value domain covers only a specific area and quickly comes to its limits when it comes to irrational numbers. Having a basic idea of how a computer codes decimal numbers it should be clear that there is the need for different data types in R, which means we can now start to look at the elementary data types our software environment provides. If you want a deep dive on pitfalls when it comes to floating point arithmetic you should have a look at the article called What every Computer Scientist should know about floating-point Arithmetic which is freely available. "],["numeric.html", "2.2 Numeric", " 2.2 Numeric Atomic vectors, which are the base element of all higher order data structures can be of different types or modes. The mode is a mutually exclusive classification of objects according to their basic structure. The atomic modes are numeric, complex, logical, factors and character. A single object, even if not atomic, can only have a single mode. You can look up the mode using the command mode(). The atomic mode numeric can be divided into two types, one for natural numbers, called integer and one for floating point numbers called double. As of now the reasons why these two cases were separated should be obvious - it is quite easy and memory efficient to store a natural number as we do not need an exponent and the whole set of conventions we discussed earlier. Contrary to this, it is quite complex to store a floating point number, which consumes - dependent on our desired precision - more bits and therefore more memory. Let’s have a quick look at what R has to offer here: vec &lt;- 1:5 mode(vec) ## [1] &quot;numeric&quot; typeof(vec) ## [1] &quot;integer&quot; sequence &lt;- seq(1 , 5 , by=.5) typeof(sequence) ## [1] &quot;double&quot; # Mixing integers and doubles will produce a vector of type double mixed &lt;- c(1:5 , seq(1 , 5 , by=.5)) typeof(mixed) ## [1] &quot;double&quot; Generally, R stores numbers as double and will use integers only when easily applicable or if you specifically force R to treat a number as an integer using the as.integer() command. A vector of type integer uses less memory than a vector of type double with the same length. The reason for this is the internal representation of numbers we discussed at the beginning of this chapter. "],["complex.html", "2.3 Complex", " 2.3 Complex R can handle complex numbers. It is doubtful that you will come across them when doing simple data analysis, but likely if you are performing more advanced calculations for e.g. in time series analysis. You can simply create a complex vector by adding an imaginary term to a real number. num &lt;- sqrt(as.complex(-64)) typeof(num) ## [1] &quot;complex&quot; num &lt;- 1 + 2i typeof(num) ## [1] &quot;complex&quot; is.complex(num) ## [1] TRUE Re(num) # Returns real part of a complex number ## [1] 1 Im(num) # Returns imaginary part of a complex number ## [1] 2 To perform more calculations or obtain more information when dealing with complex numbers you can also use Mod() for the modulus and Arg() for the argument of a given complex number. "],["logical.html", "2.4 Logical", " 2.4 Logical Logicals can hold the value TRUE or FALSE and are often the output of comparisons. To fulfill your need for typing efficiency when programming R allows you to abbreviate TRUE and FALSE by T respectively F. x &lt;- TRUE x ## [1] TRUE 1 &gt; 5 ## [1] FALSE bool &lt;- c(T, F, T, F, T) bool ## [1] TRUE FALSE TRUE FALSE TRUE sum(bool) # ATTENTION: Automatic conversion to 1 (T) and 0 (F) ## [1] 3 When using TRUE and FALSE in calculations they are automatically converted into their underlying numerical representation. We are going to talk about this phenomenon called coercion in detail in the respective chapter. When it comes to logical values R provides a lot of operators to compare and evaluate objects - these are called logical operators. Code Description Syntax &gt; Greater than a &gt; b &gt;= Greater than or equal to a &gt;= b &lt; Less than a &lt; b &lt;= Less than or equal to a &lt;= b == Exactly equal to a == b != Not equal to a != b ! Logical negotiation (NOT) !a | OR (elementwise) a | b || OR (stepwise) a || b &amp; AND (elementwise) a &amp; b &amp;&amp; AND (stepwise) a &amp;&amp; b %in% Is element in group of elements a %in% c(a,b,c) xor() Exclusive or (XOR) xor(a,b) A lot of these logical operators can come in handy when structuring your code and using conditional statements to handle different events or cases in your program. If you don’t know how they are working you can just try them out while giving a and b different TRUE or FALSE values or you can construct a truth table in the following way. values &lt;- c(NA, FALSE, TRUE) names(values) &lt;- as.character(values) outer(values, values, &quot;&amp;&quot;) # Truth table for AND ## &lt;NA&gt; FALSE TRUE ## &lt;NA&gt; NA FALSE NA ## FALSE FALSE FALSE FALSE ## TRUE NA FALSE TRUE outer(values, values, &quot;|&quot;) # Truth table for OR ## &lt;NA&gt; FALSE TRUE ## &lt;NA&gt; NA NA TRUE ## FALSE NA FALSE TRUE ## TRUE TRUE TRUE TRUE Operations using logicals can sometimes be tricky and seem to be wrong or trying to fool you. So pay attention when dealing with them and try to get a sense of how they are evaluated. Here is an example of a tricky evaluation. To understand the following lines you should know what the exclusive or (xor) does and what differentiates it from the normal or. Trying to come up with a line of code to construct a truth table for this in R may help to understand the following: xor(T, T) == T | T ## [1] TRUE xor(T,T) ## [1] FALSE T | T ## [1] TRUE FALSE == TRUE # This is obviously wrong ## [1] FALSE Although it seems as R is making an error here, it does not. It evaluates our line of code in a strictly logical order and this differs from the appearance of the equation. Here is how R evaluates the parts of our expression: # Due to the definition of XOR the expression has to be FALSE xor(T,T) == T|T ## [1] TRUE xor(T,T) # 1. Step ## [1] FALSE xor(T,T) == T # 2. Step ## [1] FALSE xor(T,T) == T|T # 3. Step ## [1] TRUE F|T # Aggregation (same as 3. step) ## [1] TRUE # If you want R to behave as it seems on first look you have # to use parentheses: xor(T,T) == (T|T) # Evaluates each side individually, then compares ## [1] FALSE The following code illustrates the difference between | and || and shows why using || as operator for the logical OR can come in handy sometimes. Remember that the logical OR returns TRUE if at least one element is TRUE. When the first element is TRUE, the result is independent of the second element. rm(x) # Make sure variable x does not exist TRUE | x # Element x does not exist, so R returns an Error! ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found TRUE || x # Element x does not exist, but the result can be determined ## [1] TRUE # without actually touching the object and || ensures that # the execution is aborted as soon as possible. "],["character.html", "2.5 Character", " 2.5 Character Character vectors store pieces of text from a single character to whole sentences. You can easily create a character vector by putting text in quotes and R will handle the rest for you. char &lt;- &quot;TRUE&quot; typeof(char) ## [1] &quot;character&quot; num &lt;- &quot;3.14&quot; # num * 3 # This produces an error as.numeric(num) * 3 ## [1] 9.42 An often occurring mistake is confusing numbers imported as characters with numerics. The conversion comes in handy when handling data and it is good advice to check datatypes if your calculations with important data look suspicious or won’t work at all. "],["factors.html", "2.6 Factors", " 2.6 Factors Factors are helpful to represent nominally and ordinally scaled variables. 2.6.1 Unordered Factors x &lt;- factor(c(&quot;yes&quot;,&quot;yes&quot;,&quot;no&quot;,&quot;yes&quot;,&quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: no yes table(x) ## x ## no yes ## 2 3 unclass(x) # Levels are automatically generated in alphabetical order! ## [1] 2 2 1 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; x &lt;- factor(c(&quot;yes&quot;,&quot;yes&quot;,&quot;no&quot;,&quot;yes&quot;,&quot;no&quot;), levels = c(&quot;yes&quot;,&quot;no&quot;)) unclass(x) # By setting levels explicitly the internal order can be defined. ## [1] 1 1 2 1 2 ## attr(,&quot;levels&quot;) ## [1] &quot;yes&quot; &quot;no&quot; x[1] == x[3] # Nominally scaled variables can be check for equality ## [1] FALSE 2.6.2 Ordered Factors An example for an ordered factor are ordinally scaled variables, which are often found in questionnaires, like the likert scale. likert &lt;- factor(c(2,3,1,5,2,4,5,2,3,3), levels = c(1,2,3,4,5), labels = c( &quot;strongly disagree&quot;, &quot;disagree&quot;, &quot;don’t know&quot;, &quot;agree&quot;, &quot;strongly agree&quot;), ordered = TRUE) likert ## [1] disagree don’t know strongly disagree strongly agree ## [5] disagree agree strongly agree disagree ## [9] don’t know don’t know ## 5 Levels: strongly disagree &lt; disagree &lt; don’t know &lt; ... &lt; strongly agree likert[1] &lt; likert[2] ## [1] TRUE likert[1] &gt; likert[2] ## [1] FALSE likert[1] + likert[2] ## Warning in Ops.ordered(likert[1], likert[2]): &#39;+&#39; is not meaningful for ordered ## factors ## [1] NA likert[1] == likert[5] ## [1] TRUE "],["missing-and-raw-data.html", "2.7 Missing and Raw Data", " 2.7 Missing and Raw Data Besides the atomic data types, R supports two more types. A missing or undefined value is indicated by NA which stands for non-available. This is in fact not a real data type, R considers this type a logical value. A lot of functions support handling data with NAs in the set and provide different options to use the respective dataset anyway. Watch out to not mistake NA for the reserved term NaN, which indicates erroneous calculations. num &lt;- c(1 , 2 , NA , 4 , 5) num + 3 ## [1] 4 5 NA 7 8 is.na(num) ## [1] FALSE FALSE TRUE FALSE FALSE sum(is.na(num)) # Number of NAs in dataset ## [1] 1 which(is.na(num)) # Location/Index of the NA ## [1] 3 mean(num) # Mean of the data can not be calculated ## [1] NA mean(num , na.rm=T) # Omitting the NA for caluclating mean ## [1] 3 R also supports RAW vectors meaning data stored in hexadecimal notation. The hexadecimal system is a companion from our well-known decimal system and the binary system we talked about at the beginning of this chapter. Hexadecimal numbers are numbers with base \\(b = 16\\). This may get handy when reading in files in binary formats. To find additional information about how to work with the type RAW see the corresponding help pages with ?raw. raw(3) # Create empty raw vector of length 3 ## [1] 00 00 00 x &lt;- as.raw(15) # Convert number to raw x ## [1] 0f typeof(x) ## [1] &quot;raw&quot; "],["coercion-attributes-and-class.html", "2.8 Coercion, Attributes, and Class", " 2.8 Coercion, Attributes, and Class 2.8.1 Coercion We have already seen that R coerces data types sometimes automatically. That makes it possible to calculate the sum of a vector consisting of logical values, which basically tells you how many elements with value TRUE are present. R has strict rules on how it behaves when coercing data types. If a string is present in a vector everything will be converted to strings. When there are only logicals and numbers in a vector R converts the logicals to their numeric value, so that every TRUE becomes 1 and every FALSE becomes a 0. The main corresponding goal here is to not lose information but conserve it at the cost of memory requirements and compatibility. A graphical representation is shown in the following figure. Figure 2.1: Coercion Cycle and Coercion Rules Data frames and lists can handle multiple data types in the same structure, but there is a good reason not to mix everything up in a huge data frame and this reason is Math. Using only vectors containing a single type of data is a big advantage, as it is easy to perform mathematical operations using matrices and vectors which couldn’t be done with a mixed type data structure and as they are so easy to store in memory these operations are fast. 2.8.2 Attributes and Names Attributes are R’s interpretation of metadata. They can be attached to any type of object but won’t affect your calculation or other operations and they won’t be displayed when you display the object. That makes it very convenient to store a description or any additional information you want to handover with your object. Of course, you can access the attributes within functions which allows you to perform special tasks if a data has given attributes. Here is how you assign and display attributes. x &lt;- 1:5 attributes(x) # A simple numeric vector has no attributes ## NULL As you can see above, the result that is being returned is NULL, which is neither equivalent to 0 nor NA. NULL is short for the NULL-Pointer which is a computer scientists term for an empty set \\(\\{\\varnothing\\}\\). Every time R returns NULL it just wants to express that there is nothing there. description &lt;- list(Description = &quot;Simple numerical vector&quot;) attributes(x) &lt;- description attributes(x) ## $Description ## [1] &quot;Simple numerical vector&quot; Another form of adding descriptive information to your data is by using the names() function. This is useful for datasets and you can imagine this as a header for your data. This is by far the most common way to enrich data in R. With names it is the same as with other attributes. They won’t affect the behavior of the vector meaning you can still perform all calculations names(x) ## NULL names(x) &lt;- c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;) x ## one two three four five ## 1 2 3 4 5 ## attr(,&quot;Description&quot;) ## [1] &quot;Simple numerical vector&quot; x &lt;- x^2 x ## one two three four five ## 1 4 9 16 25 ## attr(,&quot;Description&quot;) ## [1] &quot;Simple numerical vector&quot; names(x) &lt;- NULL # To delete names set them to NULL x &lt;- unname(x) # Alternative way to remove the names x ## [1] 1 4 9 16 25 ## attr(,&quot;Description&quot;) ## [1] &quot;Simple numerical vector&quot; 2.8.3 Class A class in R is a property assigned to an object that describes the type of stored data in some way. Classes are used to control how generic functions like summary() behave. It is not a mutually exclusive classification. If an object has no specific class assigned to it, such as a simple numeric vector, its class is usually the same as its mode. If you transform data e.g. from a vector to a matrix, R will automatically change the class attribute. num &lt;- 1:10 class(num) ## [1] &quot;integer&quot; typeof(num) == class(num) ## [1] TRUE mod &lt;- lm(wage ~ 1 + education) # Regression from previous chapter class(mod) ## [1] &quot;lm&quot; When summarizing the objects mod with the linear model inside and the numeric vector num one can easily see that different outputs, dependent on the class of the objects, are produced. The same mechanism can also be used to define own generic functions and dynamically and conveniently control their behavior. summary(num) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 3.25 5.50 5.50 7.75 10.00 summary(mod) ## ## Call: ## lm(formula = wage ~ 1 + education) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.3396 -2.1501 -0.9674 1.1921 16.6085 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.90485 0.68497 -1.321 0.187 ## education 0.54136 0.05325 10.167 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.378 on 524 degrees of freedom ## Multiple R-squared: 0.1648, Adjusted R-squared: 0.1632 ## F-statistic: 103.4 on 1 and 524 DF, p-value: &lt; 2.2e-16 "],["exercises-1.html", "Exercises", " Exercises EX 1 Write down a truth table for the exclusive or. EX 2 What does double mean in the context of computer science? EX 3 What is TRUE + TRUE? Why? EX 4 Create the following data structure. ## x y z ## 1 1 c TRUE ## 2 3 b FALSE "],["data-manipulation.html", "Chapter 3 Data Manipulation", " Chapter 3 Data Manipulation You might not think that programmers are artists, but programming is an extremely creative profession. It’s logic based creativity. – John Romero We already introduced data structures, namely vectors, matrices, lists, and data frames and performed some basic tasks with them. R supports, of course, many more interesting and advanced actions to manipulate data in any desired way. "],["vectors.html", "3.1 Vectors", " 3.1 Vectors We have already seen that we can access a subset of a vector using brackets. This option is far more powerful than shown before when combining the brackets with other operators. vec &lt;- 1:10 vec[5] # Show fifth element ## [1] 5 vec[1:3] # Show first to third element ## [1] 1 2 3 vec[-1] # Exclude first element ## [1] 2 3 4 5 6 7 8 9 10 vec[-length(vec)] # Exclude last element ## [1] 1 2 3 4 5 6 7 8 9 R provides handy commands like any() and all() to manipulate data and perform fast logic tests. any(vec &gt; 5) ## [1] TRUE all(vec &lt; 10) ## [1] FALSE all(vec[-length(vec)] &lt; 10) ## [1] TRUE You can also use brackets to filter data and advise R to only return specific values which match your filter criteria. vec[vec &gt; 5] # Brackets can hold expressions to filter data ## [1] 6 7 8 9 10 vec[vec &gt; 7] &lt;- 0 # Setting all observations &gt; 7 to zero vec ## [1] 1 2 3 4 5 6 7 0 0 0 subset(vec, vec &lt; 5) # subset() can also be used to filter data ## [1] 1 2 3 4 0 0 0 Using which() it is possible to perform actions on indices which can be used to remove values from a vector for example. which(vec &lt; 1) # Get indices of zeros in vec ## [1] 8 9 10 vec[which(vec &lt; 1)] ## [1] 0 0 0 vec.positive &lt;- vec[-which(vec &lt; 1)] # Remove zeros from vec vec.positive ## [1] 1 2 3 4 5 6 7 As in the real world, there are always multiple solutions to a problem. If you want to remove the zeros from the shown vector vec there are additional ways to receive the same result as for vec.positive in a more efficient, but not always more clear way. Make sure to understand the following solutions in addition to the one shown using which(). vec[vec &gt; 0] # Nice, clean and efficient ## [1] 1 2 3 4 5 6 7 subset(vec,vec &gt; 0) # Same result using a function ## [1] 1 2 3 4 5 6 7 vec[-vec &lt; 0] # Also right, but not clear or fast ## [1] 1 2 3 4 5 6 7 Let us have a detailed look at how the third and maybe confusing solution is derived. You should not use it as the others shown are more clear and way nicer, but it illustrates nicely how weird a solution can be achieved. -vec ## [1] -1 -2 -3 -4 -5 -6 -7 0 0 0 -vec &lt; 0 ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE vec[-vec &lt; 0] ## [1] 1 2 3 4 5 6 7 "],["matrices-and-arrays.html", "3.2 Matrices and Arrays", " 3.2 Matrices and Arrays Matrices support the same operations as vectors and of course, you can formulate ambitious filtering commands to extract or manipulate data. mat &lt;- matrix(1:25, nrow = 5) 10 %% 3 # Modulo operation ## [1] 1 mat %% 2 == 1 ## [,1] [,2] [,3] [,4] [,5] ## [1,] TRUE FALSE TRUE FALSE TRUE ## [2,] FALSE TRUE FALSE TRUE FALSE ## [3,] TRUE FALSE TRUE FALSE TRUE ## [4,] FALSE TRUE FALSE TRUE FALSE ## [5,] TRUE FALSE TRUE FALSE TRUE mat[which(mat %% 2 == 1)] ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 Matrices as known from undergraduate mathematical courses usually have two dimensions. Sometimes there is the need for more dimensions and of course, R supports us with a construct that is similar to a more dimensional matrix - this structure is called an array. If you already played around with other programming languages you may insist, that an array does not need to have three or more dimensions, which is absolutely right. You can imagine array as a generic term for a (numeric) n-dimensional data-structure. A vector, therefore, can be called a one-dimensional array while matrices can also be called two-dimensional arrays. If you store data in a three-dimensional structure - the array is normally called a cube, but of course, we are not limited to three dimensions. Cubes of higher dimensions are usually called Hypercubes or just referred to as arrays. To printout, our n-dimensional structure on the two-dimensional command-line R gives back the array in slices. The command to create an array is array(). A &lt;- array(c(1:9 , 11:19 , 21:29), dim=c(3 , 3 , 3)) A # Display array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 11 14 17 ## [2,] 12 15 18 ## [3,] 13 16 19 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 21 24 27 ## [2,] 22 25 28 ## [3,] 23 26 29 dim(A) ## [1] 3 3 3 When entering higher dimensions the complexity level increases drastically and may get confusing. During our data science journey, we mostly use two-dimensional structures and therefore won’t explore the world of n-dimensional arrays here. "],["lists.html", "3.3 Lists", " 3.3 Lists Lists are somewhat similar to arrays because a list can contain another list and so on. This makes lists slightly more complicated than matrices. If we access an element within a list with the []-Operator we get another list as output. To access the value of a list (within a list) we must use the double bracket [[]]-operator. The single bracket element tells you which subelement of a list is displayed and the double bracketed indices give you the specific element. L &lt;- list(5:10,c(&quot;C++&quot;,&quot;R&quot;,&quot;Phyton&quot;),c(TRUE , FALSE)) L[1] ## [[1]] ## [1] 5 6 7 8 9 10 typeof(L[1]) ## [1] &quot;list&quot; typeof(L[[1]]) ## [1] &quot;integer&quot; L[[2]][2] # Accessing a specific element ## [1] &quot;R&quot; L[2][2] # Works only with double brackets ## [[1]] ## NULL "],["dataframes.html", "3.4 Dataframes", " 3.4 Dataframes Dataframes are only lists consisting of vectors of equal length, so all the list specifics also do apply for dataframes. Nevertheless, if we are operating in special matrix-like structures R supports us with a bunch of specialized functions that allow us to perform very fast manipulations. Some of the useful functions provided by R are merge(), apply(), sweep(), stack(), aggregate() and transform(). Merging rows and columns We already discussed the functions rbind() and cbind() to merge data, especially matrices by row or by column. But if handling more complex datasets this won’t get rid of duplicates, contained in each table, manually. Exactly for these cases the merge()-function was created. d &lt;- data.frame(ID=1:4,list( Name=c(&quot;Homer&quot;,&quot;Marge&quot;,&quot;Bart&quot;,&quot;Lisa&quot;), Age=c(38 , 34 , 10 , 8), Sex=c(&quot;m&quot;,&quot;f&quot;,&quot;m&quot;,&quot;f&quot;) )) e &lt;- data.frame(ID=c(1,4,3,2),list( Name=c(&quot;Homer&quot;,&quot;Lisa&quot;,&quot;Bart&quot;,&quot;Marge&quot;), Height=c(182 , 120 , 122 , 223), Weight=c(108 , 33 , 35 , 58) )) # Merge even works with unsorted dataframes and matches the datasets # fully automatically using common columns. merge(d,e) ## ID Name Age Sex Height Weight ## 1 1 Homer 38 m 182 108 ## 2 2 Marge 34 f 223 58 ## 3 3 Bart 10 m 122 35 ## 4 4 Lisa 8 f 120 33 To add rows in a similar and clever way there are packages available to take care of cases that can’t be solved with rbind(). One of these functions is called smartbind() from the package gtools. Apply functions to rows and columns A common, very fast and unbelievable useful helper is the function apply() which allows us to apply any function to every row or column of a dataframe. The function works in this way: apply(data, MARGIN=\\#, FUN=function() ). MARGIN indicates if the function defined in FUN should be applied to rows MARGIN=1 or columns MARGIN=2. FUN can be equal to any function, including self-written ones. mat &lt;- matrix(1:10,byrow=T,ncol=5) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 apply(mat,MARGIN=1,FUN=mean) # Equivalent to rowMeans() ## [1] 3 8 apply(mat,MARGIN=2,FUN=sum) # Equivalent to colSums() ## [1] 7 9 11 13 15 This case is only to illustrate how apply() works. For the cases shown are specific functions like rowMeans() or colSums() available which are faster and should be used. In addition to apply() there are two more functions which can be used to apply the desired function on a list: lapply() and sapply(). They differ only in their output. The function lapply() outputs a list, while sapply() outputs a vector if that’s possible. They follow the exact same syntax as apply(). Sweep out Statistics in a Matrix The function sweep() sweeps out a summary statistics in a way defined by the argument FUN with subtraction as default operation. In addition to apply() this allows for very fast and completely vectorized manipulations. sweep(mat , MARGIN = 1 , STATS = c(1 , 10)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 1 2 3 4 ## [2,] -4 -3 -2 -1 0 sweep(mat , 1 , apply(mat , 1 , mean)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] -2 -1 0 1 2 ## [2,] -2 -1 0 1 2 But sweep() is much more powerful than it seems on first sight. Dividing a column by its mean can also easily done with sweep by passing the argument FUN to it. mat &lt;- matrix(rep(1:5 , 2) , byrow = T , ncol = 5) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 1 2 3 4 5 sweep(mat , 2 , colMeans(mat) , FUN = &quot;/&quot;) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1 1 1 1 ## [2,] 1 1 1 1 1 If you have problems using the sweep function you may want to convert your (sub-) dataframe to a numeric matrix, this can be done with data.matrix(). Concatenate all values from a dataframe To concatenate all values from multiple columns of a dataframe one can use the function stack() which outputs a dataframe with the stacked values while ignoring character columns. d.stacked &lt;- stack(d) # Stacks all numeric values of dataframe d d.stacked # Display the stacked data ## values ind ## 1 1 ID ## 2 2 ID ## 3 3 ID ## 4 4 ID ## 5 Homer Name ## 6 Marge Name ## 7 Bart Name ## 8 Lisa Name ## 9 38 Age ## 10 34 Age ## 11 10 Age ## 12 8 Age ## 13 m Sex ## 14 f Sex ## 15 m Sex ## 16 f Sex You may have noticed the column ind in the resulting output. This shows the origin of the data and makes the stacking fully reversible with the command unstack(), except for eventually lost string containing columns of the dataframe. Splitting dataframes while applying functions The function aggregate() allows us to split dataframes into subpopulations according to a provided measure and apply the desired function to each population. aggregate(d$Age,by=list(Sex=d$Sex),FUN=mean) ## Sex x ## 1 f 21 ## 2 m 24 Transformations without recreating dataframes The function transform() can easily be used to manipulate columns in a dataframe without the need to recreate the entire dataframe. # Adding two new lines to the dataframe d d &lt;- data.frame(d,list( Height=c(182 , 223 , 122 , 120), Weight=c(108 , 58 , 35 , 33) )) d # Display the extended dataframe ## ID Name Age Sex Height Weight ## 1 1 Homer 38 m 182 108 ## 2 2 Marge 34 f 223 58 ## 3 3 Bart 10 m 122 35 ## 4 4 Lisa 8 f 120 33 transform(d,Height=Height/100, BMI=Weight/(Height/100)^2) ## ID Name Age Sex Height Weight BMI ## 1 1 Homer 38 m 1.82 108 32.60476 ## 2 2 Marge 34 f 2.23 58 11.66321 ## 3 3 Bart 10 m 1.22 35 23.51518 ## 4 4 Lisa 8 f 1.20 33 22.91667 "],["strings.html", "3.5 Strings", " 3.5 Strings Strings are not only used to provide a description of your data. When dealing with more complex programs they become more and more useful. An often used case is creating variables while a program is running and using the created variables in the same instance to perform calculations without knowing the exact scheme of the variable names. This programming technique is called dynamic variable naming and we are going to explore this later in the course. But to be able to handle strings we need a couple of useful functions to deal with them. When creating functions that output calculations on the command line like the lm()-function does when calculating linear models, it is useful to manipulate the appearance in the output to create a better readable experience for the user. string &lt;- c(&quot;Statistics&quot;,&quot;and&quot;,&quot;calculus&quot;,&quot;are&quot;,&quot;wonderful!&quot;) string ## [1] &quot;Statistics&quot; &quot;and&quot; &quot;calculus&quot; &quot;are&quot; &quot;wonderful!&quot; noquote(string) ## [1] Statistics and calculus are wonderful! cat(string) ## Statistics and calculus are wonderful! Additional useful functions to manipulate the appearance of output are print(), format() and sprintf(). To concatenate strings into a single variable we commonly use the c()-function, if we really want to combine multiple strings into a single one we can use paste(). letters # Reserved word for all 26 small letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS # Reserved word for all 26 capitalized letters ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; paste(letters[1:5],LETTERS[1:5],sep=&quot;+&quot;) ## [1] &quot;a+A&quot; &quot;b+B&quot; &quot;c+C&quot; &quot;d+D&quot; &quot;e+E&quot; paste(letters[1:5],LETTERS[1:5],collapse=&quot;&quot;,sep=&quot;&quot;) ## [1] &quot;aAbBcCdDeE&quot; If you want to create a bunch of variable or column names consisting of the same string, but different numbers you can simply pass that string and a vector of numbers to paste() and it will return the desired combinations, which then can be used to name the columns of a dataframe for example. paste(&quot;name&quot; , 1:3 , sep=&quot;&quot;) # Easy name or variable generation ## [1] &quot;name1&quot; &quot;name2&quot; &quot;name3&quot; To extract substrings or to split a string to a certain scheme R provides the functions substring() and strsplit(). If you want to search through a string you can use grep() to find the respective index of the searched string in a bigger string or vector of strings. To replace parts of a string R provides the commands gsub() to replace all occurrences and sub() to replace the first occurrence in the target string. If you are familiar with Linux or the world of Unix-based operating systems you may already be familiar with a lot of these string manipulating functions. In fact, most of these functions found in R can also be found in your favorite Linux shell as they originated from there. # To convert a String to upper or lower cases one can use the # functions toupper() and tolower(). identical(toupper(letters),LETTERS) ## [1] TRUE grep(&quot;K&quot;, LETTERS) # Returns index of searched string ## [1] 11 string &lt;- paste(rep(letters,2),collapse=&quot;&quot;,sep=&quot;&quot;) string ## [1] &quot;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz&quot; gsub(&quot;o&quot;,&quot;X&quot;,string) ## [1] &quot;abcdefghijklmnXpqrstuvwxyzabcdefghijklmnXpqrstuvwxyz&quot; sub(&quot;o&quot;,&quot;X&quot;,string) ## [1] &quot;abcdefghijklmnXpqrstuvwxyzabcdefghijklmnopqrstuvwxyz&quot; If you have a more complex task like finding generic patterns in strings or simply want to find more than just simple predefined letters or words you may want to make yourself familiar with regular expressions. Regular expressions (regex) allow you to come up with a generic description of what should be searched and returned in textual data and they often come in handy when you want to extract specific parts of a textual dataset for further processing. As the syntax of regex is quite confusing when seen for the first time and textual data isn’t our main focus here we skip this part. Nevertheless, if you are interested in using them the built-in help system provides an excellent starting point when asked for ?regex. "],["dates-and-times.html", "3.6 Dates and Times", " 3.6 Dates and Times Dates and times in computer science can easily fill a bunch of books. There are different time formats, different data types and there are countless routines to handle, measure and manipulate time objects. So let us focus on the basics to implement basic features in your programs when it comes to times. In R we have two simple methods to obtain the current time. date() ## [1] &quot;Wed Jan 6 09:15:47 2021&quot; Sys.time() ## [1] &quot;2021-01-06 09:15:47 UTC&quot; Once we have a date we can encode and convert it to a POSIXlt-Object with the function strptime(). POSIX-Objects store the number of elapsed seconds since the 1. January 1970 - 00:00. Once we have a POSIXlt-Object it is easy to extract things like the month using the function months() or the day of the week using weekdays(). Sys.setlocale(&quot;LC_TIME&quot;,&quot;C&quot;) # Set regional parameters once ## [1] &quot;C&quot; strptime(&quot;15/mar/88&quot;,format=&quot;%d/%b/%y&quot;) ## [1] &quot;1988-03-15 UTC&quot; date &lt;- strptime(&quot;15/mar/88&quot;,format=&quot;%d/%b/%y&quot;) weekdays(date) ## [1] &quot;Tuesday&quot; months(date) ## [1] &quot;March&quot; As you can see in the code snippet above you need to pass a proper format argument to the function strptime() in order to decode or encode the given time accordingly. This may look like hieroglyphs at first sight but is indeed quite easy to learn. The following table provides an overview of the most useful codes. A more extensive reference can be found in the help system (?strptime) or in the Linux man pages, as the POSIX standard also originated from the Unix-universe. Code Input / Output %a and %A Abbreviated and full weekday name in the current locale. %b and %B Abbreviated and full month name in the current locale. %d Day of the month as decimal number (01-31). %e Day of the month with leading space for single decimal numbers (1-31). %H Hour as decimal number (00-23). %m Month as decimal number (01-12). %M Minute as decimal number (00-59). %S Seconds as decimal number including 2 leap seconds (00-61). %T Equivalent to %H:%M:%S. %U Week of the year as decimal number (00-53). %V Week of the year as decimal number as defined in ISO 8601 (01-53). %W Week of the year as decimal number (00-53, UK convention). %y Year without century (00-99). %Y Year with century (ISO 8601:2004). %F Equivalent to %Y-%m-%d (ISO 8601 date format). %D Date format such as %m/%d/%y (ISO C99 date format). When operating with POSIX-Objects we can perform lots of useful tasks which make handling time objects really convenient like comparing them and calculating the elapsed time between two events. Event1 &lt;- as.POSIXlt(&quot;1989-11-09&quot;) # Fall of Berlin wall Event2 &lt;- as.POSIXlt(&quot;1949-05-23&quot;) # Founding date of BRD Event1 - Event2 ## Time difference of 14780 days difftime(Event1, Event2, units=&quot;hours&quot;) ## Time difference of 354720 hours Event1 &gt; Event2 ## [1] TRUE At this point, we are quite well equipped with knowledge to handle and manipulate all common appearances of data, but programming is much more. Data is important but we can leverage its ability only when we have more powerful tools to automatize dealing with it. "],["exercises-2.html", "Exercises", " Exercises EX 1 The function ´apply´ offers three main arguments ´X´, ´MARGIN´, ´FUN´. Please explain their purpose and possible parameterization options. EX 2 What is the idea behind the additional three dot argument ´…´ (dotdotdot) that can be set when using ´apply´? EX 3 Please explain the following three lines of code (line by line): x &lt;- cbind(x1 = 3, x2 = c(4:1, 2:5)) dimnames(x)[[1]] &lt;- letters[1:8] apply(x, 2, mean, trim = .2) EX 4 Explain the difference between the two function calls without executing them. paste(&quot;variable&quot;, 1:5, sep=&quot;&quot;) paste(&quot;variable&quot;, 1:5, collapse=&quot;&quot;, sep=&quot;&quot;) EX 5 What does the following code produce? Please derive the output and explain what happens before executing the code. mat &lt;- matrix(1:4, nrow=2) mat2 &lt;- mat %% 2 == 0 apply(mat2, 2, function(x){x[1]|x[2]}) EX 6 Calculate the average value of each column in the following matrix ´m´ after removing lines 10, 24 and 30-37. set.seed(5) m &lt;- matrix(sample(1:10^7), ncol=10, byrow=T) EX 7 Try to come up with an explanation of what the following code does and why it works. &#39;[&#39;(mat, 2, 2) "],["structure.html", "Chapter 4 Code Structure", " Chapter 4 Code Structure “Begin at the beginning,” the King, said gravely, “and go on till you come to the end; then stop.” – Lewis Carroll, Alice in Wonderland Like every other real programming language, R provides tools to structure your code based on conditional expressions meaning executing a part of the code dependent on a condition and loops to describe and perform similar tasks in a compact way. If you have no prior programming experience this may seem to be the hardest thing in the world, because you have to think of all the possible cases which occur in your situation to differentiate between them in your program. Additionally, you have to think in iterations, which means you have to find the common parts of your problems and put them into loops. But let us start at the beginning and look at conditional expressions. "],["conditional-expressions.html", "4.1 Conditional Expressions", " 4.1 Conditional Expressions If and Else The most basic conditional expression is an if-statement. It is used to make expressions contingent on a certain condition and in R it has the following syntax. if ( condition ) { code # Only executed if &#39;condition&#39; is TRUE } # A simple example x &lt;- 1 if (x &gt; 0) { cat(&quot;Hello World!&quot;) } ## Hello World! The condition is a set of commands that produce a single logical value namely TRUE or FALSE and the code in the body encapsulated by { } is only executed if the condition is TRUE. If the first condition is not true it is possible to include an else statement which should be evaluated if the first condition cannot be fulfilled. if ( condition ) { code # Only executed if &#39;condition&#39; is TRUE } else { alternate code # Evaluated if &#39;condition&#39; is FALSE } There may be cases where two logical values are not enough to implement what you want. In this case, you can combine as many if clauses as you want with the statement else if and catch the rest of the cases (if none of your conditions is fulfilled) with a single else clause. x &lt;- 314 if ( x &lt; 10 ) { cat(&quot;X is a small number!&quot;) } else if ( x &gt; 100 ) { cat(&quot;X is a big number!&quot;) } else { cat(&quot;X is neither a big nor a small number!&quot;) } ## X is a big number! When using logical operators it may be better to use double symbol notation &amp;&amp; rather than single symbol notation &amp; (same with logical OR). The reason for this is because the double symbol notation evaluates the condition step by step from left to right and aborts and returns a value if a FALSE is found. This makes the execution of the code much more efficient, faster and so the way to go. However one should carefully check the evaluated expressions in order to avoid errors which can easily sneak in here. There is a good reason that conditional expressions heavily rely on the usage of the word else. It seems that everything can be solved using ifs only. While this is (sometimes) possible it is not advisable. Normally conditional expressions are mutually exclusive choices so that code can easily get confusing or erroneous. Let us consider the following example which would work perfectly fine and make much more sense with added elses. if ( x &gt; 100 ){ cat(&quot;X is a big number!&quot;) } ## X is a big number! if ( x &gt; 10 ){ cat(&quot;X is a moderate number!&quot;) } ## X is a moderate number! if ( x &gt; 1 ){ cat(&quot;X is a small number&quot;) } ## X is a small number Another point to discuss is accuracy. When comparing objects in a setting such as the one discussed here, it is often better to use the functions isTRUE() or !isTRUE() rather than the combination of a logical operator and a logical value like T == and T != to evaluate a condition. This is due to the fact that conditional expressions, as well as conditional clauses, only work if there is a single (!!!) logical value provided, which can be enforced using functions that always return only a single value. One of the pitfalls are problems related to the precision of the calculations. Precision problems as the following one can also be solved using the function all.equal() which allows to set a tolerance argument and evens out the small precision problems in floating point calculations. num1 &lt;- 0.2 - 0.1 num2 &lt;- 0.3 - 0.2 num1 == num2 ## [1] FALSE all.equal(num1 , num2 , tolerance=10^-5) ## [1] TRUE As speed is one of the most important things about programming and vectorized commands are pretty fast, there is also a vectorized if/else version in R. ifelse( condition , ifTRUE , ifFALSE) # This is really fast! x &lt;- 1:3 ifelse( x &gt; 1 , x^2 , FALSE) ## [1] 0 4 9 Switch If you are using a lot of if/else constructs in your code this may get a little bit crowded and probably messy. R provides also a statement called switch() to return values contingent on a certain expression. This is also faster than combining lots of if-statements in your code but usually not as fast as the vectorized ifelse(). switch( statement , case1 , case2 , ... ) # Basic syntax # Example if &#39;statement&#39; is numeric x &lt;- 2 switch(x,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) ## [1] &quot;two&quot; # Example if &#39;statement&#39; is a string x &lt;- &quot;mean&quot; data &lt;- c(1 , 5 , 7.5) switch(x,&quot;sd&quot;=sd(data),&quot;median&quot;=median(data),&quot;mean&quot;=mean(data)) ## [1] 4.5 If the provided statement is a number then R returns the case with the matching index. If the statement is of type string, then R tries to match the statements and executes the code listed there. Using strings as a statement and formatting your code in a structured way you can receive the same appearance and feeling like you would with switch-case-statements in other programming languages. The following code block shows alternative formatting (just some additional curly braces, spaces, and newlines) that create a look similar to other programming languages such as C or Java. However, one should be careful with switch as the behavior is not always totally intuitive as the following example shows. usertype &lt;- &quot;caseXX&quot; switch(usertype, case1 = { 1 }, case2 = , case3 = {2.5}, 99) ## [1] 99 This maps case2 to the value defined in case3 and additionally supplies and unnamed default value 99 for cases that are not defined or cannot be matched. If there is more than one match, the first matching element is used. For more information, try ?switch. Despite being special in some cases switch is usually faster than a lot of if and else statements and keeps your code more organized. "],["loops.html", "4.2 Loops", " 4.2 Loops Loops are one of the most used and most important constructs while programming - they are somehow like the universal workhorse. Generally, a loop is a control structure which allows running specific lines of code over and over again until an exit condition is fulfilled or until a specified number of repetitions has been performed. While executing the same code several times the provided data can, of course, be alternated which makes loops very useful when performing a huge number of actions of the same type. For-Loop A for loop runs specified code a fixed number of times. Therefore, you have to know in advance how often the code in the body of the loop should be executed. The for loop has the following general form. for ( idx in vector){ # Basic syntax code } The typical iterator variable i that is commonly used in other programming languages should be avoided in R because it is already a reserved word for the imaginary unit when working with complex numbers. Common workarounds are using it (short for iterator), ii (just doubled to avoid using the reserved word) or idx (abbreviation for iteration index). x &lt;- 1:3 for ( idx in x) { print(idx) } While-Loop The while loop loops until the specified condition is false. It is often used when you do not know and can not calculate in advance how often the instructions will be executed. It has the following general form. while ( condition ){ # Basic syntax code } idx &lt;- 6 while ( idx &lt; 10 ){ print(idx) idx &lt;- idx + 2 } Repeat The repeat loop is somehow similar to the while loop. The while loop starts a new run every time the condition is evaluated as TRUE while the repeat loop will always begin a new run and will only stop if it is told to do so with the break command. This means you can explicitly control which part of the loop should be executed and when the execution should be stopped. counter &lt;- 0 # Counter variable to count loops repeat{ # Repeat does not need a condition x &lt;- rnorm(1) counter &lt;- counter + 1 if (x &gt; 2) { print(counter) print(x) break } } Break and Next We have already seen that break is able to abort the repeat-loop, but it is much more powerful and can break any of the discussed loops directly. Even if you can use break to abort loops on certain conditions this is a bad habit. It is always better to know when and how a loop should end and do this via the condition or by predefining the number of loops using the for loop. The next command is used to skip the following statements and if used in a loop it will increment the loop variable (idx in the for loop example). Here is a simple example to illustrate how both are working. for ( idx in 1:100) { x &lt;- rnorm(1) if (x &lt; 0) next print(x) if ( abs(x) &gt; 3) break # Break should normally be avoided } Generally one can say that loops in R are pretty slow and in most of the cases drastically slow down your code. Therefore, where possible loops should be avoided! In most of the cases it is much better (and faster!) to use vectorized functions like apply(), sapply() or tapply(). Special: Looping over non-numerical data R does not exactly support looping over non-numerical data, but it may be useful sometimes and of course, there are a few ways to accomplish this. The first one is using a function of R’s mighty apply()-family. In this case lapply() is the way to go if the performed and desired loops are independent of each other and it is allowed to process them in any order. Another option is using the function get(). In fact, the purpose is straight forward and sounds very simple. It takes a character string as an argument and returns the object of that name. Here is a short example of how to calculate the mean of three vectors. x &lt;- rnorm(10) y &lt;- rnorm(1000) z &lt;- rnorm(1000000) for ( idx in c(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;)) { vec &lt;- get(idx) print(mean(vec)) } ## [1] -0.452227 ## [1] -0.02234161 ## [1] -0.001333537 This simple example may give you an idea of how powerful the get()-function is. Try to imagine how flexible and powerful a routine written with the combination of get() and paste() can be. This does, however, not cover all possible cases, for example, if you want to loop over the elements of a list by name, the above example using get() won’t work. list &lt;- list(x=x, y=y, z=z) for ( idx in names(list)){ print(list$idx) } ## NULL ## NULL ## NULL Of course there is a way to force R looping over the names and fetch the data. To achieve this you have to construct a string and then make R evaluate this string using the command eval(). for ( idx in names(list)){ string &lt;- paste(&quot;list$&quot;,idx,sep=&quot;&quot;) # Constructing command data &lt;- eval(parse(text=string)) # Evaluating command print(mean(data)) # Working with fetched data } ## [1] -0.452227 ## [1] -0.02234161 ## [1] -0.001333537 The shown example is, of course, arbitrary and the result could have been achieved easier using numeric values for idx and double brackets to address the i-th element in the list. Nevertheless, it shows Rs capabilities to loop over non-numeric content and gets really useful if you are dealing with more complex ways of addressing data. If you want to read R code from a file or are looking for another option to evaluate a concatenated string you can also use the source()-command. "],["exercises-3.html", "Exercises", " Exercises 99 Bottles of Beer In early 1994, when the internet was only used by a fraction of the people that are using it today, someone posted the full lyrics of the song 99 Bottles of Beer to a humor mailing list, which was also heavily used by programmers. This was seen as an enormous waste of bandwidth because the lyrics could have been easily posted using six lines of BASIC code. This small event was the occasion for Tim Robinson to develop and post his version of the song in C++ which inspired other programmers to post their version of the song which since then has been ported to nearly every programming language available and is one of the many classic yet funny stories from the early ages of the internet. The song has the following lyrics: 99 bottles of beer on the wall, 99 bottles of beer. Take one down and pass it around, 98 bottles of beer on the wall. \\[ \\vdots \\] 2 bottles of beer on the wall, 2 bottles of beer. Take one down and pass it around, 1 bottle of beer on the wall. 1 bottle of beer on the wall, 1 bottle of beer. Take one down and pass it around, no more bottles of beer on the wall. No more bottles of beer on the wall, no more bottles of beer. Go to the store and buy some more, 99 bottles of beer on the wall. [END] Write a function called bottlesong() that outputs the famous and complete lyrics of the song 99 Bottles of Beer. 4.2.1 Multiplication Table Write a function mulitplicationtable() that outputs the multiplication table including results from \\(1 \\cdot 1 = 1\\) up to \\(10 \\cdot 10 = 100\\) to the console. The function should rely on loops, results should be calculated at runtine and the time delay between the output of two consecutive lines to the command line should be user-definable. The following block shows an abbreviated example output. 1 x 1 = 1 1 x 2 = 2 1 x 3 = 3 ... 10 x 9 = 90 10 x 10 = 100 4.2.2 Diagonal Matrix Write a function that creates a symmetric matrix with dimension \\(n x n\\), that contains a value x on every element, except for the elements on the main diagonal which should contain value y. Wrap your code in a function diagmat() and make all mentioned values user-definable. The following block contains an example output: "],["software-development.html", "Chapter 5 Software Development", " Chapter 5 Software Development First, solve the problem. Then, write the code. – John Johnson Most programming projects start small and are not intended to grow. However, this is exactly what happens and after some time you are confronted with a large, complex and diffuse code base where nobody - including yourself - understands how the programs really work. Good coding style is like correct punctuation when using natural language. You can live without it, but it makes things a lot easier to understand and better to read. The reasons to advocate a good programming style are manifold: Errors: Good programming style helps to avoid errors, saves time when searching and correcting mistakes and reduces embarrassment that normally occurs if errors cannot be found. Collaboration: It occasionally occurs that problems are solved in teams rather than alone, a good programming style eases the handover and reduces introduction efforts when joining projects. It may also happen that someone (researcher, colleague) has to maintain or use your program. Good programming style eases the process of understanding dramatically. Publications: Supervisors for thesis or seminar papers as well as scientific journals usually want to know (implementations details) about data and estimation procedures to support transparency and reproducibility of scientific work. From an academic point of view, the quality of the provided code is often considered when grading assignments, theses or homework. Memories: Humans usually overestimate how much they remember and usually underestimate the necessity for future changes. Months after finishing or suspending a project, most people have forgotten the details and difficulties as well as dependencies when modifying the code. Your future ‘you’ will have the same problems as any colleague that has to use your code if you haven’t looked at it for a couple of months. Developing software is an intensive field of research, it has a lot in common with organization and project management, but usually is a lot more formalized. Many of the more popular Software Development Frameworks (SDF), like Rapid Application Development (RAD), Scrum, Extreme Programming (XP) or the Agile Unified Process (AUP) achieved attention and are actively adopted by other industries. All these frameworks, processes or however you want to refer to them have one thing in common and this is to ensure that a high-quality output (usually in terms of software) is being produced by one or more developers. While modern (agile) SDFs are usually used to manage teams and do not have distinct phases, more traditional approaches emphasize the idea of software development life cycle, where phases like planning, coding, documenting or testing occur sequentially rather than simultaneously. One of these process models is the software development waterfall, which clarifies the essential steps when writing software. Figure 5.1: Waterfall Software Development Process The basic idea of the process is to divide the whole development project into sequential phases, where overlap and ‘splashbacks’ are tried to be avoided. As in traditional project management, the emphasis is on planning time schedules, target dates, and budgets, while the implementation of an entire system is done at once. The transition to the next phase usually requires the approval of a customer or user and written project documentation is an explicit deliverable of each phase. The sequential nature and the resulting “inflexibility” in a pure waterfall model have been a source of constant criticism. In practice, the waterfall model has been superseded by more flexible and dynamic approaches and when working in teams a more agile SDF, e.g. Scrum, should be chosen as these eradicate many pitfalls found in the waterfall SDF. However, all of the following stages are always present and must be considered when developing software, regardless of the specific management approach. "],["planning.html", "5.1 Planning", " 5.1 Planning Especially in scientific environments software usually fulfills a strict purpose and solves an (academic) problem. The planning phase, therefore, captures the user requirements and aligns them with the prospective software architecture. The output of this phase usually is a document with the requirements and a plan for the software architecture. For good software, it is key to separate the actual coding from the planning phase. Usually, it is a good idea to start a new project with an empty sheet of paper and collect the theoretical and practical aspects to form a sketch of the possible solution. Do not think about technical details in this phase too much, but write down your ideas in pseudo code like load data, transform (scale and logarithmize) input, calculate regression coefficients, * analyze error terms*. Sub-problems that occur multiple times or code that needs to be executed more than once should be modularized and needs to be put into a function. This avoids inconsistencies and provides a single place to maintain functionalities and implement changes. Besides this, functions have additional advantages - they make the code more readable and facilitate testing and validation. When wrapping boring sections like data transformation in a function this can usually be done by a single line of code including easily visible arguments. Therefore, you can think of modules like building blocks to your solution, each block (function) should handle a single task and not more. In addition to solving one thing well, functions should be flexible and solve a sufficiently general problem. It is more advisable to make a function flexible and solve the n-dimensional case (and avoid hard-coding the 2-dimensional case), as your requirements may increase over time. The general steps and the building blocks of functions can be combined into an architecture that solves the specific problem. Proceeding this way, the problem is being divided into simpler steps and each sub-problem is solved individually (Principle: Divide and Conquer). It is always advisable to support the planning process with a graphical representation that allows to easily discover dependencies and the right sequence of commands. While computer and system sciences lead to a huge variety of “modeling languages” even simple graphical representations are often useful. A lot of problems and requirements have already been solved and implemented by other programmers and quite often there is no need to reimplement every little step on your own. It is fair and good practice to reuse, modify and recycle existing packages, libraries, functions or code fragments. “Whenever possible, steal code” is one of the many bits of advice frequently given to new programmers. While this is usually good advice and shortens the implementation and coding requirements it still comes at the cost of understanding and integrating someone else’s code into your project. While code often can be freely found in the web, it still comes with some requirements and liabilities which are usually bundled in the respective license that is linked or distributed with the code. Regardless of the license under which the software is distributed the usage of someone else’s ideas or intellectual property - especially in scientific projects - needs to be cited. If you use R packages they conveniently provide a reference that can be cited and is accessible with the command citation(\"packagename\"). If citation() is used without an argument it returns the reference for the R Base System. citation() ## ## To cite R in publications use: ## ## R Core Team (2020). R: A language and environment for statistical ## computing. R Foundation for Statistical Computing, Vienna, Austria. ## URL https://www.R-project.org/. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2020}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in creating R, please cite it ## when using it for data analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; for ## citing R packages. Integrating other functions, packages or code fragments means to organize and handle how different functions hand over data, which means one has to think about the data format and use standard data formats wherever possible. Choosing or creating a data format is not to be mistaken by choosing a file extension like .txt,.csv or .ppt but defines the structure of your list, data.frame or comparable data-structure present in R. Choosing a standard, therefore, refers to choosing the type of object that captures, organizes and stores data, estimation results or other output. This is important for several reasons as bad designs of the data structures make the coding more difficult and the program less readable. Often one needs to consider that empirically derived results are almost never perfect or satisfactory after a first run and need to be recalculated on different subsets or transformations of the data. A designed data structure needs to combine all results including the envelope and meta information, like function arguments, etc. Last but not least a clever and compact design of the resulting data structure can affect the actual execution speed of a program significantly. Choosing a standard or convention is especially important. Imagine when using a matrix to store individual observations for e.g. multiple time series it makes sense to store the observations in rows and the variables/time series in columns. Additionally, one needs to think about missing values in the data (e.g. calendarial effects like holidays) and how to handle them. "],["coding.html", "5.2 Coding", " 5.2 Coding Writing code that a computer can understand is actually quite easy - we have even written a simple function in the very first unit of this course. Good code, however, is written for humans to read and only incidentally for machines to execute. It, therefore, is good practice to write code with a reader in your mind (e.g. your supervisor for a thesis, a colleague or your grandparents). Most of the problems tackled in scientific projects can as well be solved with simple solutions. Advanced logic and aiming for short solutions (e.g. one-liner) may make code hard to read and even harder to understand. The objectives to head for when writing software are therefore clarity and brevity. Speed is important, but there is no necessity to tweak out every little bit of performance (in terms of speed and memory) and this should only be the chosen path if it is really necessary. To ensure readability you should adopt standard code layouts. While normal analyses and simple programming exercises usually can be pretty well organized with a few R files (.R), bigger projects normally rely on more advanced structures such as R Project files (.Rproj) and Packages. Being an introductory course we focus on simple organization schemes and refer to the appendix (for a very short introduction) and the literature. Figure 5.2: Exemplary simple Project Skeleton Apart from simple analyses, most projects require some software development and own functions that are used to analyze a respective dataset. Custom functions should be separated from the pure analysis if they reach a critical mass (which is usually the case), so that it is good advice to separate the code base into two files, like in the figure above. The following chapters discuss the layout of these files before introducing and discussing some additional principles and things to consider when filling the files with actual code. 5.2.1 Standard Program Structure The standard program structure contains the actual analysis (contrary to own functions) and should contain the following elements: Headline: The Name of the Program Preamble: A short text explaining the purpose and basic principles of the program, what it does and how it is intended to be used; including a license statement if necessary. Author: Name and contact information of the author(s), the (release) date and the version of the software. If multiple versions exist, the version information in the form of a changelog can be handed out. Program: The actual program divided into parts or blocks. Dependencies: Here external dependencies like libraries or a custom function file should be loaded. If the function file would only contain a few short function definitions it makes obviously no sense to create an own file for them. As long as the readability of the function file is not affected the function definitions could also be included here. Constants: Constant values that your program relies on and values that parameterize the methods used below should be user changeable, bundled and included in the second block, directly after loading external dependencies. Problem Solving: Here the actual problem solving takes place. Of course, this part can be divided into multiple parts or blocks. Output: The output generated by your analysis usually plots, tables or PDFs should be created and exported in the last block of the program. # Example of Standard Program Structure # This is an example skeleton of a Standard Program Structure that can be used # to structure own programs and analyses. It was written purely for educational # purposes and is part of the lecture notes for the course &#39;Computational # Statistics using R&#39;. # Author: Benjamin Buchwitz (benjamin.buchwitz@ku.de) # Date: 01.01.1970 # Version Changelog: # v0.1 - Initial Release # v0.2 - Major Improvements in Speed and Stability ################################################################################ ## PART I: Load Libraries and external Dependencies ################################################################################ # Loading installed packages ------- library(ggplot2) library(forecast) # Loading own functions ------------ setwd(&quot;~/projectName&quot;) # Set working directory to project folder source(&quot;projectName_functions.R&quot;) ################################################################################ ## PART II: Define Constants ################################################################################ a &lt;- 0.5 # Initial calibration Parameter n &lt;- 100 # Length of simulated Data T.eff &lt;- 80 # Value used in the Model x &lt;- rnorm(n) # Data; standard normally distributed y &lt;- rnorm(n) + 5 # Data; mean shifted to 5 ################################################################################ ## PART III: Problem Solving ################################################################################ res &lt;- CalculateSampleCovariance(x, y, verbose=FALSE) ... ################################################################################ ## PART IV: Output Results ################################################################################ # Save estimation results ---------- saveRDS(res, &quot;projectName_results.rds&quot;) # Create publication ready plots --- pdf(&quot;plotexample.pdf&quot;) plot(x, y, main=&quot;An awesome Plot&quot;) dev.off() 5.2.2 Standard Function Structure The second file contains the functions and should have the following structure. Headline: The Name of the Program that the functions belong to Preamble: A short text explaining the purpose and basic principles of the functions, what they do and how they are intended to be used; including a license statement if necessary. This can be the same text as in the file described above. Function Definitions: Actual definitions of the functions. Each function definition should retain the following structure: First Line: Function Constructor and Name of the function Preamble: The preamble of a function fulfills similar purposes as the preamble of the file that contains the analysis or function itself. It contains a headline that very briefly describes what the functions do. If necessary an additional text describes the function and its extended purposes or way of implementation. After that all Arguments of the function are introduced and described. Finally, the output, including the corresponding data structure is described. Body: The Code that actually solves the Problem. # Example file with Standard Function Structure # This is an example skeleton that contains a Standard Function Structure. The # functions defined here are needed to for the Standard Program Structure above. # It was written purely for educational purposes and is part of the lecture # notes for the course &#39;Computational Statistics using R&#39;. # Author: Benjamin Buchwitz (benjamin.buchwitz@ku.de) # Date: 01.01.1970 # Version Changelog: # v0.1 - Initial Release # v0.2 - Major Improvements in Speed and Stability ################################################################################ ## Function Definitions ################################################################################ #&#39; Computes the sample covariance between two vectors. #&#39; #&#39; This function calculates the ordinary sample covariance between two vectors, #&#39; it is intended to be either used by a user directly and is also used in #&#39; some other functions, e.g. when calculating the correlation coefficient. #&#39; #&#39; @param x One of two vectors whose sample covariance is to be calculated. #&#39; @param y: The other vector. x and y must have the same length, greater than #&#39; one, with no missing values. #&#39; @param verbose Logical. If TRUE, prints sample covariance; if not, output #&#39; is suppressed. Default is TRUE. #&#39; #&#39; @return The sample covariance between x and y. CalculateSampleCovariance &lt;- function(x, y, verbose = TRUE) { n &lt;- length(x) # Error handling if (n &lt;= 1 || n != length(y)) { stop(&quot;Arguments x and y have different lengths: &quot;, length(x), &quot; and &quot;, length(y), &quot;.&quot;) } if (TRUE %in% is.na(x) || TRUE %in% is.na(y)) { stop(&quot; Arguments x and y must not have missing values.&quot;) } covariance &lt;- var(x, y) if (verbose) cat(&quot;Covariance = &quot;, round(covariance, 4), &quot;.\\n&quot;, sep = &quot;&quot;) return(covariance) } ... 5.2.3 Naming Convention While the aforementioned Standard Program Structure and the Standard Function Structure regulate what should be presented when developing code it is still unclear how functions, arguments, objects, classes or files should be named. Naming things is considered one of the more tricky parts in computer science. As it may be complicated to change e.g. a function name after it has been heavily used in other functions one needs to adopt a clear and vivid naming scheme. This also ensures that named functions, classes, etc. speak for themselves and is essential to produce readable and self-explaining code. The following list shows some popular naming conventions that all more or less frequently occur in several programming languages. Of course, not all developers that produce and distribute R software follow the same naming conventions. The function names given in the list below are R functions to illustrate how and where the respective naming scheme can be found within R. The shown list including some additional discussion can be found in the R Journal. alllowercase: All letters are lower case and no separator is used in names consisting of multiple words as in searchpaths or srcfilecopy. This naming convention is common in MATLAB. Note that a single lowercase name, such as mean, conforms to all conventions but UpperCamelCase. period.separated: All letters are lower case and multiple words are separated by a period. This naming convention is unique to R and used in many core functions such as as.numeric or read.table. underscore_separated: All letters are lower case and multiple words are separated by an underscore as in seq_along or package_version. This naming convention is used for function and variable names in many languages including C++, Perl, and Ruby. lowerCamelCase: Single word names consist of lower case letters and in names consisting of more than one word all, except the first word, are capitalized as in colMeans or suppressPackageStartupMessage. This naming convention is used, for example, for method names in Java and JavaScript. UpperCamelCase: All words are capitalized both when the name consists of a single word, as in Vectorize, or multiple words, as in NextMethod. This naming convention is used for class names in many languages including Java, Python, and JavaScript. When working in professional software development teams or joining existing projects one usually has to adapt to the defined naming convention. However, when developing alone one should still follow some rules. A good set of rules to follow are these ones: A Personal Naming Convention This naming convention applies to variables, functions, and R files. Files that contain R code are always saved with the extension .R. All names are self-explaining English words, usually not abbreviated and at least 3 letters long. I use the singular even if numerous entries are expected. Example: price, duration, strike. Names for objects and functions use the lowerCamelCase naming scheme with the modifications listed below. Exceptions to (1) and (2) are widely used single-letter symbols and widely used acronyms. For both, I use only uppercase letters. Examples: X, Y in regression analysis or FFT, GDP. Uppercase letters concatenate words. The following rules apply to concatenated names: – Names of variables start with the most general term and end with the most specific (the latter usually denoting a certain method). Examples: optionPriceFFT, optionPriceAnalytic, optionStrike. – Names of functions start with the name of the project, followed by the object of the function, what it does and finally the specific method. Examples: wishartOptionPricingFFT, wishartOptionPricingCosfft, wishartOptionPlotting. To avoid confusion, I use the prefix “my”. This may be necessary if one variable is used locally to calculate a variant of a model or if the name conflicts with an existing R command. Example: myLinearModel, myDate. Use common Sense and be CONSISTENT! When you reach a point, where the naming convention fails do not use it in this special case and check if it needs to be adapted and improved. Recommendations following: Gruber (2013) - Solving Economics and Finance Problems with MATLAB. 5.2.4 Rules &amp; Best Practices The following presents some rules and best practices that are widely adopted by programmers and have been proven useful: Comment your code. Each line of a comment should begin with the comment symbol # and a single space. Comments should explain the why, not the what. Check twice if the comment is clear and if it is really needed. Rely on commented lines of ######, #==== or #---- to break up your file into easily readable chunks. While writing your code you can collapse these sections in RStudio so that you do not have to scroll over them every time. If you want to implement a feature later or if you assign the responsibility to implement something to a team member choose a consistent style for TODOs throughout your code. # TODO(username): Explicit description of action to be taken. Use White Space and indentation to structure your code, but avoid the tabular key (RStudio helps you by translating every tab into 2 spaces automatically). Aim for a code width of 80 characters or less, so that your code can be printed if necessary and stays fully visible in text editor windows with moderate width (avoid the necessity to scroll vertically). RStudio provides support for this by displaying a thin grey line in the code editor, that can be enabled via the menu under Tools -&gt; Global Options Dialogue. Choose the Code pane and select the Display tab to checkmark the “show margin column” option. It is pretty easy to find a case for which we have not discussed a rule yet. Due to the sheer complexity of the topic, we, therefore, rely on some popular examples to follow. Many professional developers have spent and effort to conceptualize complete style-guidelines, some with complete naming schemes and some without one. The following links will point to the most common style guides for R and you are encouraged to choose one (in addition to the things already discussed) when developing software. Note that none of these style guides is an official R standard and that there is (and possibly never will be) no such thing. The Tidyverse Style Guide Google’s R style guide Hadley Wickham’s Style Guide Bioconductor’s Coding Standards Colin Gillespie’s R Style Guide "],["documenting.html", "5.3 Documenting", " 5.3 Documenting Software that is intended to be used needs to be documented. During the coding chapter, we actually covered a few important steps that already contain documentation of a program. Generally, the provided documentation for a program can be divided into code documentation and user documentation. Examples for the code documentation are the comments that explain the implemented steps directly in the code, while the user documentation usually consists of long term documentation such as a vignette or accompanying book to explain what the developed software does. 5.3.1 Code Documentation (Short-form Documentation) Code documentation is sometimes also referred to as short-form documentation. As mentioned previously it supports readers of your code, mainly while using the code. It is intended to briefly explain arguments to functions and basic working principles. R in combination with various packages support you by documenting your code. The documentation style using the modified comment #' is implemented by the package roxygen2. It allows creating a help page directly from the function preamble, that is later accessible via the R help system ?. This is useful and saves a lot of work as this part of the documentation can be written at the same moment as the software itself. However, to be available via the ? operator, it is required that your code will be delivered to users as an R package. While we have not covered that yet, it is still beneficial to form a habit of documenting your code this way. The following table provides a short overview of some tags that you can (and should) use when documenting your code. Tag Explanation @param Describe function parameter @return Indicate what the function returns @examples Possible usage example of the function @seealso Function that may be relevant to understand @author Author of the respective function @keywords Contextual topic of the function @references Web or academic reference to the function However, the roxygen2 package is not limited to these tags but provides excessive options that are especially useful when developing R packages. A brief overview of capabilities and options for the roxygen engine is available in a Cheat Sheet. 5.3.2 User documentation (Long-form Documentation) Long-form documentation describes the program, which can consist of a single or multiple functions, in more detail. It provides insights on what the program does and is the right place to elaborate on implementation details or explain the statistical or mathematical theory behind your routine. Long form documentation is usually called a vignette and can be anything from a short technical note over a journal article to a complete book. It can, therefore, serve as user documentation, allowing and explaining possible customization options and describe everything in more detail than the accompanying code documentation. Available documentation for an installed package can be viewed using the function vignette(). vignette(package=&quot;forecast&quot;) Vignettes in package ‘forecast’: JSS2008 Automatic Time Series Forecasting: the forecast Package for R (Hyndman &amp; Khandakar, JSS 2008) (source, pdf) For example, the vignette for the forecast package is a journal article that was published in the Journal of Statistical Software (JSS). It will be downloaded when installing the package or, as the JSS is an open access journal, is also available to be downloaded here. A good way to write long-form documentation is using RMarkdown, which is a specialized version of Markdown - a plain text formatting system. R Markdown hast multiple advantages: it is strictly focussed on content, can intermingle text and results from code executions and is tightly integrated into RStudio. It is, therefore, the optimal solution for documenting programming challenges, solving assignments or writing theses that rely on R. The syntax employed by Markdown is simple and straightforward and it allows you to produce many kinds of output such as HTML, pdf or even Microsoft Word documents. "],["testing.html", "5.4 Testing", " 5.4 Testing Software testing is an investigation conducted to provide stakeholders with information about the quality of the tested code. Its goal is to generate an independent view of the software that allows understanding of how the developed product can affect its (business) environment. In professional environments, this allows finding bugs and verifies that the software product is fit for production purposes. Software testing involves the execution of a software component (e.g. a small function) or system component (e.g. a large function or a whole package) and evaluates at least one property of interest. This can, for example, be the requirements that have been noted when planning the program. Testing usually checks the behavior of the software under all kinds of inputs, evaluates the response time and efficiency and simulates conditions in practical uses. As the number of possible tests is almost infinite, professional developers employ test strategies that intend to find errors, unexpected results or general misbehavior. As all discussed steps in this chapter, testing is an iterative process. Fixing one error can lead to previously hidden deeper bugs or can even create new ones. As this is not a course on software engineering, we limit our testing framework to the following rules of thumb that can serve as a guideline after writing our first programs. Test in an organized and modular way, ideally by making a plan. Check every function separately. Test every scenario at least twice, especially when you have modified your function or fixed an error. Find and test boundary values. Test for different and deliberately false input. Do not only look for errors, often warnings reveal much more subtle problems, that need to be resolved. Document what you test. A more comprehensive way of testing in an automated fashion is provided by the testthat package, which is the most popular unit testing solution in R. However, as this is an introductory course we do not cover automated testing in more detail. "],["maintaining.html", "5.5 Maintaining", " 5.5 Maintaining Software systems evolve and need adaptation as well as fixes to continuously deliver results for their users. Maintenance allows preserving the value that the software provides over time. Generally, maintenance is any change to the software after it has been used for production purposes for the first time. The key software maintenance issues are both managerial and technical ones. Usually, maintenance tasks include error fixing, capabilities extensions, removing obsolete capabilities, and process or functionality optimizations. Productive software requires strict versioning to allow users as well as developers to keep track of the changes. While simple programs that are being written for simple analyses or software that implements research prototypes often only require a single “release”, this is obviously different for business and professional applications. Naturally, maintenance in a research context is not that intensively discussed, and as this is an introductory course we abstain from further explanations here. However, maintaining the value a software delivers has to be kept in mind for bigger and continuous projects. "]]
